
#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_MODULE libmace
#include <boost/test/unit_test.hpp>
#include "ContextBaseClass.h"
#include "ThreadStructure.h"

/* emulate the context class auto-generated by mace compiler */
class ChildCtx: public mace::ContextBaseClass{
public:
  ChildCtx(const mace::string& contextID="ChildCtx", const uint64_t ticket = 1 ):
  mace::ContextBaseClass(contextID, ticket) { }
  ChildCtx( const ChildCtx& _ctx ) : v(_ctx.v) { }
  uint32_t v;
  void snapshot( const uint64_t& ver ) const {
    ChildCtx* _ctx = new ChildCtx(*this);
    mace::ContextBaseClass::snapshot( ver, _ctx );
  }
  const ChildCtx& getSnapshot() const {
    return static_cast< const ChildCtx& >(  mace::ContextBaseClass::getSnapshot()  );
  }
  void setSnapshot(const uint64_t ver, const mace::string& snapshot){
    std::istringstream in( snapshot );
    ChildCtx *obj = new ChildCtx (this->contextID,1  );
    mace::deserialize(in, obj);
    versionMap.push_back( std::make_pair(ver, obj) );
  }
  void serialize(std::string& __str) const {
    mace::serialize(__str, &v);
  }
  int deserialize(std::istream& __in)  throw (mace::SerializationException){
    int serializedByteSize = 0;
    serializedByteSize += mace::deserialize(__in, &v);
    return serializedByteSize;
  }
};
BOOST_AUTO_TEST_SUITE( lib_ContextBaseClass )

BOOST_AUTO_TEST_CASE( CreateDeleteContextClass )
{
  mace::ContextBaseClass* ctx = new mace::ContextBaseClass("Test",1);

  delete ctx;
}

//-----------------------------------------------------------------
BOOST_AUTO_TEST_SUITE( Snapshot )
BOOST_AUTO_TEST_CASE( Test1 )
{
  uint64_t ticket = 1;
  uint64_t event = 1;
  ThreadStructure::setTicket( ticket );
  ThreadStructure::setEvent( event );
  mace::ContextBaseClass* ctx = new mace::ContextBaseClass("Test",event);
  ctx->snapshot( event );
  ctx->snapshotRelease( event );
  delete ctx;
}
BOOST_AUTO_TEST_CASE( Test2 )
{
  uint64_t ticket = 1;
  uint64_t event = 1;
  ThreadStructure::setTicket( ticket );
  ThreadStructure::setEvent( event );
  mace::ContextBaseClass* ctx = new mace::ContextBaseClass("Test",event);
  ctx->snapshot( event );
  ctx->getSnapshot();
  ctx->snapshotRelease( event );

  delete ctx;

}
BOOST_AUTO_TEST_CASE( Test3 )
{
  uint64_t ticket = 1;
  uint64_t event = 1;
  ThreadStructure::setTicket( ticket );
  ThreadStructure::setEvent( event );
  ChildCtx* ctx = new ChildCtx("Test.Child",event);
  ctx->v = 5566;
  ctx->snapshot( event );
  ctx->v = 520;
  const ChildCtx& ctxSnapshot = ctx->getSnapshot();
  BOOST_REQUIRE_EQUAL( ctxSnapshot.v, (uint64_t)5566 );
  ctx->snapshotRelease( event );

  delete ctx;
}
/* stress test */
BOOST_AUTO_TEST_CASE( Test4 )
{
  uint64_t ticket = 1;
  uint64_t event = 1;
  ThreadStructure::setTicket( ticket );
  ChildCtx* ctx = new ChildCtx("Test.Child",event);
  for( event = 1; event <= 1000; event++ ){
    ThreadStructure::setEvent( event );
    ctx->v = event;
    ctx->snapshot( event );
  }
  for( event = 1; event <= 1000; event++ ){
    ThreadStructure::setEvent( event );
    const ChildCtx& ctxSnapshot = ctx->getSnapshot();
    BOOST_REQUIRE_EQUAL( ctxSnapshot.v, event );
    ctx->snapshotRelease( event );
  }

  delete ctx;
}
/* TODO: test ContextLock snapshot correctness when downgrading */

BOOST_AUTO_TEST_SUITE_END()
//-----------------------------------------------------------------
BOOST_AUTO_TEST_SUITE( Serialization )
BOOST_AUTO_TEST_CASE( Test1 )
{
  uint64_t event = 1;
  ChildCtx* ctx = new ChildCtx("Test.Child",event);
  ctx->v = 5566;
  std::string s;
  mace::serialize( s, ctx );
  ctx->v = 0;
  mace::deserialize(s, ctx );

  BOOST_REQUIRE_EQUAL( ctx->v, (uint64_t)5566 );

  delete ctx;
}

BOOST_AUTO_TEST_SUITE_END()
//-----------------------------------------------------------------
BOOST_AUTO_TEST_SUITE( ContextHierarchy )
BOOST_AUTO_TEST_CASE( Test1 )
{
  uint64_t event = 1;
  mace::ContextBaseClass* ctx = new mace::ContextBaseClass("",event);
  BOOST_REQUIRE( !ctx->addNewChild("") );
  BOOST_REQUIRE( ctx->addNewChild("A") );
  BOOST_REQUIRE( ctx->addNewChild("B[0]") );
  BOOST_REQUIRE( ctx->addNewChild("C[0,1]") );
  BOOST_REQUIRE( ctx->addNewChild("C[0,test]") );

  delete ctx;
  mace::ContextBaseClass* ctx2 = new mace::ContextBaseClass("A",event);
  BOOST_REQUIRE( !ctx2->addNewChild("") );
  BOOST_REQUIRE( !ctx2->addNewChild("A") );
  BOOST_REQUIRE( !ctx2->addNewChild("B[0]") );
  BOOST_REQUIRE( !ctx2->addNewChild("C[0,1]") );
  BOOST_REQUIRE( !ctx2->addNewChild("C[0,test]") );

  BOOST_REQUIRE( ctx2->addNewChild("A.B[0]") );
  BOOST_REQUIRE( !ctx2->addNewChild("A.B[0]") );
  BOOST_REQUIRE( ctx2->addNewChild("A.C[0,1]") );
  BOOST_REQUIRE( ctx2->addNewChild("A.C[0,test]") );
  delete ctx2;

  mace::ContextBaseClass* ctx3 = new mace::ContextBaseClass("A[0]",event);
  BOOST_REQUIRE( !ctx3->addNewChild("") );
  BOOST_REQUIRE( !ctx3->addNewChild("A") );
  BOOST_REQUIRE( !ctx3->addNewChild("B[0]") );
  BOOST_REQUIRE( !ctx3->addNewChild("C[0,1]") );
  BOOST_REQUIRE( !ctx3->addNewChild("C[0,test]") );

  BOOST_REQUIRE( ctx3->addNewChild("A[0].B[0]") );
  BOOST_REQUIRE( !ctx3->addNewChild("A[0].B[0]") );
  BOOST_REQUIRE( ctx3->addNewChild("A[0].C[0,1]") );
  BOOST_REQUIRE( ctx3->addNewChild("A[0].C[0,test]") );

  BOOST_REQUIRE( !ctx3->addNewChild("A[1].B[0]") );
  BOOST_REQUIRE( !ctx3->addNewChild("A[1].B[0]") );
  BOOST_REQUIRE( !ctx3->addNewChild("A[1].C[0,1]") );
  BOOST_REQUIRE( !ctx3->addNewChild("A[1].C[0,test]") );

  BOOST_REQUIRE( !ctx3->addNewChild("A[0,1].B[0]") );
  BOOST_REQUIRE( !ctx3->addNewChild("A[0,1].B[0]") );
  BOOST_REQUIRE( !ctx3->addNewChild("A[0,1].C[0,1]") );
  BOOST_REQUIRE( !ctx3->addNewChild("A[0,1].C[0,test]") );
  delete ctx3;

  mace::ContextBaseClass* ctx4 = new mace::ContextBaseClass("A[0,1]",event);
  BOOST_REQUIRE( !ctx4->addNewChild("") );
  BOOST_REQUIRE( !ctx4->addNewChild("A") );
  BOOST_REQUIRE( !ctx4->addNewChild("B[0]") );
  BOOST_REQUIRE( !ctx4->addNewChild("C[0,1]") );
  BOOST_REQUIRE( !ctx4->addNewChild("C[0,test]") );

  BOOST_REQUIRE( !ctx4->addNewChild("A[0].B[0]") );
  BOOST_REQUIRE( !ctx4->addNewChild("A[0].B[0]") );
  BOOST_REQUIRE( !ctx4->addNewChild("A[0].C[0,1]") );
  BOOST_REQUIRE( !ctx4->addNewChild("A[0].C[0,test]") );

  BOOST_REQUIRE( !ctx4->addNewChild("A[1].B[0]") );
  BOOST_REQUIRE( !ctx4->addNewChild("A[1].B[0]") );
  BOOST_REQUIRE( !ctx4->addNewChild("A[1].C[0,1]") );
  BOOST_REQUIRE( !ctx4->addNewChild("A[1].C[0,test]") );

  BOOST_REQUIRE( ctx4->addNewChild("A[0,1].B[0]") );
  BOOST_REQUIRE( !ctx4->addNewChild("A[0,1].B[0]") );
  BOOST_REQUIRE( ctx4->addNewChild("A[0,1].C[0,1]") );
  BOOST_REQUIRE( ctx4->addNewChild("A[0,1].C[0,test]") );
  delete ctx4;

  mace::ContextBaseClass* ctx5 = new mace::ContextBaseClass("A[0].B[1]",event);
  BOOST_REQUIRE( !ctx5->addNewChild("") );
  BOOST_REQUIRE( !ctx5->addNewChild("A") );
  BOOST_REQUIRE( !ctx5->addNewChild("B[0]") );
  BOOST_REQUIRE( !ctx5->addNewChild("C[0,1]") );
  BOOST_REQUIRE( !ctx5->addNewChild("C[0,test]") );
  BOOST_REQUIRE( !ctx5->addNewChild("A[0].B[1]") );

  BOOST_REQUIRE( !ctx5->addNewChild("A[0].B[0]") );
  BOOST_REQUIRE( !ctx5->addNewChild("A[0].B[0]") );
  BOOST_REQUIRE( !ctx5->addNewChild("A[0].C[0,1]") );
  BOOST_REQUIRE( !ctx5->addNewChild("A[0].C[0,test]") );

  BOOST_REQUIRE( !ctx5->addNewChild("A[1].B[0]") );
  BOOST_REQUIRE( !ctx5->addNewChild("A[1].B[0]") );
  BOOST_REQUIRE( !ctx5->addNewChild("A[1].C[0,1]") );
  BOOST_REQUIRE( !ctx5->addNewChild("A[1].C[0,test]") );

  BOOST_REQUIRE( ctx5->addNewChild("A[0].B[1].C") );
  BOOST_REQUIRE( !ctx5->addNewChild("A[0].B[1].C") );
  BOOST_REQUIRE( ctx5->addNewChild("A[0].B[1].D[0]") );
  BOOST_REQUIRE( ctx5->addNewChild("A[0].B[1].E[0,1]") );
  BOOST_REQUIRE( ctx5->addNewChild("A[0].B[1].F[test,1]") );

  BOOST_REQUIRE(  ctx5->addNewChild("A[0].B[1].D.D") );
  BOOST_REQUIRE( !ctx5->addNewChild("A[0].B[1].D.D[0]") );
  BOOST_REQUIRE( !ctx5->addNewChild("A[0].B[1].D.D[0,1]") );
  BOOST_REQUIRE( !ctx5->addNewChild("A[0].B[1].D.D.E[0,1]") );
  BOOST_REQUIRE( ctx5->addNewChild("A[0].B[1].C[5].F[test,1]") );

  mace::set<mace::string> childctx = ctx5->getChildContextID();
  BOOST_REQUIRE( childctx.find( "A[0].B[1].C" ) != childctx.end() );
  BOOST_REQUIRE( childctx.find( "A[0].B[1].D[0]" ) != childctx.end() );
  BOOST_REQUIRE( childctx.find( "A[0].B[1].E[0,1]" ) != childctx.end() );
  BOOST_REQUIRE( childctx.find( "A[0].B[1].F[test,1]" ) != childctx.end() );
  delete ctx5;
}
BOOST_AUTO_TEST_CASE( Test2 )
{
  uint64_t event = 1;
  mace::ContextBaseClass* ctx = new mace::ContextBaseClass("",event);
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "" ) );
  BOOST_REQUIRE(  ctx->isImmediateParentOf( "A" ) );
  BOOST_REQUIRE(  ctx->isImmediateParentOf( "A[0]" ) );
  BOOST_REQUIRE(  ctx->isImmediateParentOf( "A[0,1]" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0].B[1]" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0].B[1].C" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0].B[1].D[0]" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0].B[1].E[0,1]" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0].B[1].E[0,1].F" ) );
  delete ctx;

  ctx = new mace::ContextBaseClass("A[0].B[1]",event);
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0]" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[1]" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0].B[1]" ) );
  BOOST_REQUIRE(  ctx->isImmediateParentOf( "A[0].B[1].C" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0].B[0].C" ) );
  BOOST_REQUIRE(  ctx->isImmediateParentOf( "A[0].B[1].D[0]" ) );
  BOOST_REQUIRE(  ctx->isImmediateParentOf( "A[0].B[1].E[0,1]" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0].B[1].E[0,1].F" ) );
  delete ctx;

}
BOOST_AUTO_TEST_CASE( Test3 )
{
  uint64_t event = 1;
  mace::ContextBaseClass* ctx = new mace::ContextBaseClass("",event);
  BOOST_REQUIRE( ctx->isLocalCommittable() );
  delete ctx;
}
// TODO: ensure that child context set is not altered by the latter events.
BOOST_AUTO_TEST_SUITE_END()

BOOST_AUTO_TEST_SUITE_END()
