/**
 * chuangw: 02/04/2012
 *
 * A high-level event is a conceptual execution of event. The old event model in Mace says the event starts when (1) transport layer processes a received message, (2) Timer goes off, or (3) Asynchronous event handler processes an asynchronous message. An event ends when the event handler finishes the processing. 
 *
 * In Full Context model, events are created by the head of virtual node. The head assigns a globally unique event id to the event, and routes the event to the physical node based on the context of the event. 
 * The reason for having a high-level event in addition to the existing low-level event is that a high-level event is composed of several low-level events. Low level events starts and ends on the same physical machine, whereas the conceptual, high-level event, because it can transition to different contexts during the execution, it is likely the execution of the event spans across many physical nodes.
 *
 * */
#ifndef _MACE_HIGHLEVELEVENT_H
#define _MACE_HIGHLEVELEVENT_H
// include system library header
#include <pthread.h>
// include mace library header
#include "mace-macros.h"
#include "Serializable.h"
#include "ScopedLock.h"
namespace mace{

/**
 * This class should only be created by head node.
 *
 * It creates a globally unique event id (because it's only created by head node)
 * 
 * This event class object is supposed to be carried around by messages generated by async/sync/timer calls
 * */
//enum EventTypes { StartEvent, EndEvent, TimerEvent, AsyncEvent, UndefinedEvent };
class HighLevelEvent: public Serializable{
public:
    HighLevelEvent(uint8_t type): eventType(type){
        ADD_SELECTORS("HighLevelEvent::(constructor)");
        // check if this node is the head node?

        ScopedLock sl(eventMutex);
        eventID = nextTicketNumber++;
        macedbg(1) << "Ticket " << eventID << " sold!" << Log::endl;

        if( eventType == MIGRATIONEVENT ){
            migrationEventID = eventID;
            waitToMigrate();
        }

    }
    void waitToMigrate(){
        pthread_cond_wait(&migrationCond, &eventMutex );
        // TODO: send a message to the physical where migration is requested.
        //
        // block incoming events until migration is completed
    }
    int64_t getEventID(){
        return eventID;
    }
    int8_t getEventType(){
        return eventType;
    }
    virtual void serialize(std::string& str) const{
        mace::serialize( str, &eventType );
        mace::serialize( str, &eventID   );
    }
    virtual int deserialize(std::istream & is) throw (mace::SerializationException){
        int serializedByteSize = 0;
        serializedByteSize += mace::deserialize( is, &eventType );
        serializedByteSize += mace::deserialize( is, &eventID   );
        return serializedByteSize;
    }
    void commit(){
        // chuangw: commit events in order
        
        // if all events before migration event have been committed.
        if( now_committing == migrationEventID ){
            pthread_cond_signal( &migrationCond );
        }
    }
private:
    //EventTypes eventType;
    int8_t  eventType;
    int64_t eventID;

    static pthread_mutex_t eventMutex;
    static pthread_cond_t migrationCond;
    static uint64_t nextTicketNumber;
    static uint64_t migrationEventID;
    static uint64_t now_committing;

    static const uint8_t STARTEVENT = 0;
    static const uint8_t ENDEVENT   = 1;
    static const uint8_t TIMEREVENT = 2;
    static const uint8_t ASYNCEVENT = 3;
    static const uint8_t MIGRATIONEVENT = 4;
    static const uint8_t UNDEFEVENT = 5;
public:
};

}
#endif
