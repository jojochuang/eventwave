#include "mmultimap.h"

service Paxos;

provides Consensus;

trace=high;

services {
  //use the TCP protocal to sent the msg
  Transport t = auto(shared,[reliable],[]);
}

constants {
  uint64_t DEFAULT_PAXOS_INTERVAL = 10 * 1000 * 1000;
  uint64_t DEFAULT_PAXOS_TIMEOUT = (DEFAULT_PAXOS_INTERVAL + 5 * 1000 * 1000);
}

constructor_parameters {
 uint64_t PAXOS_INTERVAL = DEFAULT_PAXOS_INTERVAL; 
 uint64_t PAXOS_TIMEOUT = DEFAULT_PAXOS_TIMEOUT;
}

states {
  //indicates that the node is now proposing
  proposing;
  //the proposal get approved, then preparing
  preparing;
}

typedefs {

}

messages {
  //proposal from a proposer
  Proposal {
    uint64_t nSequence; 
    mace::string key;
    mace::string value;
  }
  //confirm msg from an acceptor
  Promise {
    uint64_t nSequence; 
    mace::string key;
    mace::string value;
  }
  //prepare msg from a proposer
  Prepare {
    uint64_t nSequence; 
    mace::string key;
    mace::string value;
  }
  //the acceptor tell the learner the final proposal ID
  Learn {
    uint64_t nSequence; 
    mace::string key;
    mace::string value;
  }


state_variables {
  //the ID to identify the node
  uint64_t nodeID __attribute((reset(no)));
  //the content of the proposal that the node currently proposing or preparing
  mace::string key; 
  //the value of the proposal that the node currently proposing or preparing
  mace::string value;
  //the maximum value that it has confirmed
  uint64_t confirmedMaxValue __attribute((reset(no))) = 0;
  //the number of the confirm msg received from acceptor
  uint64_t nPromised;
  //the number of the majority that it has to reach
  uint64_t nMajority;
  //the highest round number that the node has begun
  int highest_rnd;
  //set a timer for the expired proposal
  timer sendtimer;
  //stores the addresses of all the nodes
  NodeSet members;
  //NodeSet<MaceKey,classcomp> members;
  registration_uid_t uid;
  /* Here goes the state_variable for the complex version of Paxos */
}

transitions {
  //It first pass all the nodes addrs to the node
  //if the state of the node is init, then change it to propose state
  downcall (state == init) maceInit() {
    //get MaceKeys from Params
    bool check = false;
    params::getBootstrapPeers(localAddress(), members, check);
    //change the state of the node
    state = proposing;
    //initial the variable
    //confirmedMaxValue = 0;
    nPromised = 0;
    nMajority = 2;
    highest_rnd = 0;
    uid = 1;
    //sort the set and get the nodeID
    /*int n = members.size();
    while (n != 0) {
      for (NodeSet::iterator i = members.begin(); i != members.end(); i++) {
        if (*i > *(i + 1)) {
          *i.swap(*(i + 1));
        }
      }
      n--;
    }*/
    nodeID = 0;
    for (NodeSet::iterator i = members.begin(); i != members.end(); i++) {
      if (localAddress() < *i) {
        break; 
      }
      nodeID++;
    }
      
  }

  //when the node receives an confirm msg from the acceptor
  upcall deliver (const MaceKey& src, const MaceKey& dest, const Promise& msg) {
    
    nPromised++;
    //when it reaches the majority, it sends prepare msg instead
    if (nPromised >= nMajority) {
      //it first change the state of the node
      state = preparing;
      //then send the prepare msg back
      for (NodeSet::iterator i = members.begin(); i != members.end(); i++) {
        downcall_route(*i, Prepare(msg.nSequence, msg.key, msg.value));
      }
      nPromised = 0;
      highest_rnd++;
      //sendtimer.schedule(PAXOS_INTERVAL);
    }

  }

  upcall deliver (const MaceKey& src, const MaceKey& dest, const Proposal& msg) {
    //when it gets a proposal from a proposer
    //it first checks if the proposal ID is greater than the current confirmed one
    //make a upcall for the proposal received
    if (msg.nSequence > confirmedMaxValue) {
      //it changes the current confirmed ID to the new one
      confirmedMaxValue = msg.nSequence;
      //and send approved msg back to the acceptor
      downcall_route(src, Promise(msg.nSequence, msg.key, msg.value));
    }

  }

  //when the node get prepare msg
  upcall deliver (const MaceKey& src, const MaceKey& dest, const Prepare& msg) {
    //it first changes the maximum confirmed ID to this one
    confirmedMaxValue = msg.nSequence;
    //and then send a msg to the leader
    upcall_notifyProposalChosen(msg.key, msg.value, 1);
    //sendtimer.cancel();
  }

  //the nodes broadcast the proposal to all the acceptors
  downcall propose(const mace::string& key, const mace::string& value) {

    for (NodeSet::iterator i = members.begin(); i != members.end(); i++) {
      downcall_route(*i, Proposal(nodeID + members.size() * highest_rnd, key, value));
    }
    //set the timer after it proposes to all the acceptors
    //sendtimer.schedule(PAXOS_INTERVAL);

  }
  //if the timer expires
  scheduler sendtimer() {
    //it first shoot an upcall notification
    upcall_notifyProposalNotChosen(key, value, 1);
    //then reset the state_variables
    //key = 
    //value = 
    nPromised = 0;
  }
}
