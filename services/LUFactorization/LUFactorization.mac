service LUFactorization;
 
typedefs {
    typedef mace::vector< mace::vector<double> > Matrix;
}
services {
    Transport tcp = TcpTransport();
}
 
states{
   compute;
}

constants {
    int32_t DEFAULT_ROWS    =   5;
    int32_t DEFAULT_COLUMNS =   5;
}
/**
chuangw:
to change default parameter values to foo, in parameters.default, set
ServiceConfig.LUFactorization.ROWS = foo and
ServiceConfig.LUFactorization.COLUMNS = foo
*/
constructor_parameters {
    int32_t ROWS = DEFAULT_ROWS;
    int32_t COLUMNS = DEFAULT_COLUMNS;
}
 
state_variables {
   Matrix initial_matrix;
   int rows;
   int columns;

   int current_iteration;
   int init_cells;
   int finished_row;
   context Row<int ROWS>{ 
      int finished_cell;
      context Column<int COLUMNS>{
         int value;
         int pivot_val;
      }
   }
 
}
// implicitly declare x,y as state variable of the context
 
transitions {
   downcall (state == init)maceInit()  {
        //sleep(3); // this is to make sure all nodes are executed.
        rows = ROWS;
        columns = COLUMNS;
        initial_matrix.resize( rows );
        for(int i=0;i< rows;i++){
            initial_matrix[i].resize( columns );
        }
 
      current_iteration = 0;
      finished_row = 0;
      init_cells = 0;
 
      for( int i=0;i< rows; i++ ){
          for( int j=0;j<columns;j++){
             async_cellInit(i,j,initial_matrix[i][j]);
             // sync calls are better actually
          }
      }
      state = compute;
 
   }
   async  [Row<row>::Column<column>](state==init)cellInit( int row, int column, int initial_val ) [locking=read]  {
      maceout<<"cellInit(row="<<row<<",column="<<column<<",initial_val="<<initial_val<<Log::endl;
      Row[row].Column[column].value = initial_val; 

      async_cellInitDone();
   }
   async cellInitDone(){
      init_cells++;
      if( init_cells == rows*columns){
          for( int i=0;i< rows; i++ )
              async_startIteration( i, current_iteration );
      }
   }
   async [Row<row>](state==compute)startIteration( int row, int current_iteration )  {
      maceout<<"startIteration(row="<<row<<",current_iteration="<<current_iteration<<Log::endl;
      Row[row].finished_cell = 0;
      async_startIterationPivot(row, current_iteration);
   }
   async [Row<row>::Column<current_iteration>] (state==compute)startIterationPivot( int row, int current_iteration )  {
      for( int k=current_iteration+1; k<columns;k++ ){
          async_updateRightward(row,k,Row[row].Column[current_iteration].value);
      }
      if( row == current_iteration )
         Row[row].Column[current_iteration].value = 1.0;
      else
         Row[row].Column[current_iteration].value = 0.0;
   }
   async [Row<row>::Column<column>] updateRightward(int row, int column, int pivot) {
      if( row == current_iteration ){
          Row[row].Column[column].value /= pivot;
          for( int r=row+1; r< rows;r++)
              async_updateDownward(r, column, Row[row].Column[column].value);
      }else{
          Row[row].Column[column].pivot_val = pivot;
      }
   }
   async [Row<row>::Column<column>] updateDownward(int row,int column, int topVal)  {
      Row[row].Column[column].value -= Row[row].Column[column].pivot_val * topVal;
      async_cellDone( row );
   }
   async [Row<row>]cellDone(int row)   {
      if( ++Row[row].finished_cell == columns - current_iteration - 1){
        Row[row].finished_cell = 0;
        async_rowDone();
      }
   }
   async  rowDone(){
      if( ++ finished_row == rows ){
         finished_row = 0;
         current_iteration++;
         for( int i=current_iteration;i< rows; i++ )
             async_startIteration( i, current_iteration );
      }
   }
}
