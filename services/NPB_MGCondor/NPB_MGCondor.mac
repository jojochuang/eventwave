/* 
 * GameOfLifeStencil.mac : part of the Mace toolkit for building distributed systems
 * 
 * Copyright (c) 2012, Bo Sang
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the names of the contributors, nor their associated universities 
 *      or organizations may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * ----END-OF-LEGAL-STUFF---- 
*/

#include "mlist.h"
#include "marray.h"
#include "mdeque.h"
#include "m_map.h"
#include "mvector.h"

#include <sys/time.h>
#include <time.h>
#include <math.h>

service NPB_MGCondor;
provides MG;

trace = med;

constants {

}

services {
    Transport tcp = TcpTransport();
}

states {

}

method_remappings {

}

constructor_parameters {
	int nxyz_default = 256;
	int nit_default = 4;
	int lm = 8;
	int lt_default = 8;
	int unit_num = 4;
}

auto_types {
	Scale {
		int Xmin;
		int Xmax;
		int Ymin;
		int Ymax;
		int Zmin;
		int Zmax;
	}

	Position __attribute((comparable(equals=default; lessthan=default))){
		int x;
		int y;
		int z;
	}

}

typedefs {
	typedef mace::vector<int> IntArray;
	typedef mace::vector<double> DoubleArray;
	typedef mace::vector< mace::vector<int> > Int2DMatrix;
	typedef mace::vector< mace::vector< mace::vector<double> > > Double3DMatrix;
	typedef mace::vector< mace::vector< mace::vector<int> > > Int3DMatrix;
}

state_variables {
		context Unit<int x, int y, int z> {
			Scale scl;
		
			mace::vector<Double3DMatrix> u;
			mace::vector<Double3DMatrix> r;
			mace::vector<Double3DMatrix> v;

      int nit;
			int lt;

			IntArray nx;
			IntArray ny;
			IntArray nz;
			
			IntArray m1;
			IntArray m2;
			IntArray m3;
			
      Int2DArray ir;
			
      int is1;
      int is2; 
      int is3; 
      int ie1;
      int ie2;
      int ie3;

      int n1;
      int n2;
      int n3;

      DoubleArray a;
			DoubleArray c;
			
			double verify_value;
		}
}

messages {
				
}

transitions {
	downcall (state=init) maceInit(){
	
	}

	async [Unit<int x, int y, int z>] initialize(int& x, int& y, int& z, Scale& arg_scl, Double3DMatrix& init_u){
			scl = arg_scl;

			a.resize(4);
			a[0] = -8/3;
			a[1] = 0;
			a[2] = 1/6;
			a[3] = 1/12;

			c.resize(4);
			c[0] = -3/8;
			c[1] = 1/32;
			c[2] = -1/64;
			c[3] = 0;

			ir.resize(3);
			for(int i=0; i<3; i++){
				ir[i].resize(8);
			}

			nx.resize(lt);
			ny.resize(lt);
			nz.resize(lt);

			m1.resize(lt);
			m2.resize(lt);
			m3.resize(lt);

			lt = lt_default;
			nit = nit_default;
			nx[lt-1] = ny[lt-1] = nz[lt-1] = nxyz_default;

			u.resize(lt);
			v.resize(lt);
			z.resize(lt);

			IntArray nsizes;
			nsizes.resize(3);
			setup(nsizes, x, y, z);
			initlize_uvr(x, y, z);

			n1 = nsizes[0];
			n2 = nsizes[1];
			n3 = nsizes[2];

			Position pos;
			pos.x=0;
			pos.y=0;
			pos.z=0;
			zero3(u[0], pos, n1, n2, n3);


			for(int i=1; i<=n1; i++){
				for(int j=1; j<=n2; j++){
					for(int k=1; k<=n3; k++){
						if( (i>=scl.Xmin&&i<=scl.Xmax) && (j>=scl.Ymin&&j<=scl.Ymax) && (k>=scl.Zmin&&k<=scl.Zmax) ){
							u[0][i-scl.Xmin][j-scl.Ymin][k-scl.Zmin] = 	init_u[i][j][k];
						}	
					}	
				}	
			}
	}

}

routines {
	[Unit<x, y, z>] void setup(IntArray& nsizes, int& x, int& y, int& z){
			int k;
			int d, i, j;

			int ax;
			int size1=3, size2=10;
			IntArray mi, ng;
			mi.resize(size1*size2);
			ng.resize(size1*size2);
			int s,  dir;
			int lb = 1;
			
			ng[  (lt-1)*size1]=nx[lt-1];
			ng[1+(lt-1)*size1]=ny[lt-1];
			ng[2+(lt-1)*size1]=nz[lt-1];
														
			for(ax=0;ax<size1;ax++)
				for(k=lt-2;k>=0;k--)
					ng[ax+k*size1]=ng[ax+(k+1)*size1]/2;
																	
			for(k=lt-2;k>=0;k--){
				nx[k]=ng[  k*size1];
				ny[k]=ng[1+k*size1];
				nz[k]=ng[2+k*size1];
			}
																																							
			for(k=lt-1;k>=0;k--){
				for(ax=0;ax<size1;ax++){
					mi[ax+k*size1] = 2 + ng[ax+k*size1];
				}
				m1[k]=mi[k*size1];
				m2[k]=mi[1+k*size1];
				m3[k]=mi[2+k*size1];
			}
			
			k = lt-1;
			is1 = 2 + ng[k*size1] - ng[k*size1];
			ie1 = 1 + ng[k*size1];
			n1=nsizes[0] = 3 + ie1 - is1;
			is2 = 2 + ng[1+k*size1] - ng[1+k*size1];
			ie2 = 1 + ng[1+k*size1]; 
			n2=nsizes[1] = 3 + ie2 - is2;
			is3 = 2 + ng[2+k*size1] - ng[2+k*size1];
			ie3 = 1 + ng[2+k*size1];
			n3=nsizes[2] = 3 + ie3 - is3;

			ir[0][lt-1] = 0;
			ir[1][lt-1] = 0;
			ir[2][lt-1] = 0;
			for(j = lt-2;j>=0;j--){
				ir[0][j]=ir[0][j+1]+m1[j+1];
				ir[1][j]=ir[1][j+1]+m2[j+1];
				ir[2][j]=ir[2][j+1]+m3[j+1];
			}
	}

	[Unit<x, y, z>] void initialize_uvr(int& x, int& y, int& z){
		Int2DMatrix temp_m;
		temp_m.resize(3);
		for(int i=0; i<3; i++){
			temp_m[i].resize(lt);
			for(int j=0; j<lt; j++){
				if(i==0){
					temp_m[i][j] = m1[j]-2;	
				}else if(i==1){
					temp_m[i][j] = m2[j]-2;	
				}else{
					temp_m[i][j] = m3[j]-2;	
				}	
			}
		}

		u.resize(lt);
		v.resize(lt);
		r.resize(lt);

		for(int i=0; i<lt; i++){
			int i1_num = temp_m[0][i]/unit_num+2;
			u[i].resize(i1_num);
			v[i].resize(i1_num);
			r[i].resize(i1_num);

			for(int i1=0; i1<i1_num; i1++){
				int i2_num = temp_m[1][i]/unit_num+2;
				u[i][i1].resize(i2_num);
				v[i][i1].resize(i2_num);
				r[i][i1].resize(i2_num);

				for(int i2=0; i2<i2_num; i2++){
					int i3_num = temp_m[2][i]/unit_num+2;
						u[i][i1][i2].resize(i3_num);
						v[i][i1][i2].resize(i3_num);
						r[i][i1][i2].resize(i3_num);
				}
			}
		}
	}

	[__null] void zero3(Double3DMatrix& matrix, Position& pos, int& n1, int& n2, int& n3){
		for(int i=pos.x; i<n1; i++){
			for(int j=pos.y; j<n2; j++){
				for(int k=pos.z; k<n3; k++){
					matrix[i][j][k] = 0;	
				}	
			}	
		}	
	}

	[__null] void comm(int& x, int& y, int& z, int& flag, Double3DMatrix& u, int& n1, int& n2, int& n3){
			Position pos;
			
			/*****************x-axle************************/
			Double2DMatrix xMatrix0, xMatrix1;
			xMatrix0.resize(n2);
			xMatrix1.resize(n2);
			for(int i=0; i<n2; i++){
				xMatrix0[i].resize(n3);
				xMatrix1[i].resize(n3);
			}
			

			for(int i3=1; i3<n3-1; i3++){
				for(int i2=1; i2<n2-1; i2++){
					xMatrix0[i2][i3] = u[1][i2][i3];
					xMatrix1[i2][i3] = u[n1-2][i2][i3];
				}	
			}

			pos.x = 1;
			pos.y = 0;
			pos.z = 0;
			if(x == 0){
				async_comm3(unit_num-1, y, z, flag, pos, xMatrix0);	
			}else{
				async_comm3(x-1, y, z, flag, pos, xMatrix0);	
			}

			pos.x = -1;
			if(x == unit_num-1){
				async_comm3(0, y, z, flag, pos, xMatrix1);	
			}else{
				async_comm3(x+1, y, z, flag, pos, xMatrix1);	
			}

			/************************y-axle***************************************/
			Double2DMatrix yMatrix0, yMatrix1;
			yMatrix0.resize(n1);
			yMatrix1.resize(n1);
			for(int i=0; i<n1; i++){
				yMatrix0[i].resize(n3);
				yMatrix1[i].resize(n3);
			}

			for(int i3=1; i3<n3-1; i3++){
				for(int i1=1; i1<n1-1; i1++){
					yMatrix0[i1][i3] = u[i1][1][i3];
					yMatrix1[i1][i3] = u[i1][n2-2][i3];
				}	
			}

			pos.x = 0;
			pos.y = 1;
			pos.z = 0;
			if(y == 0){
				async_comm3(x, unit_num-1, z, flag, pos, yMatrix0);	
			}else{
				async_comm3(x, y-1, z, flag, pos, yMatrix0);	
			}

			pos.y = -1;
			if(y == unit_num-1){
				async_comm3(x, 0, z, flag, pos, yMatrix1);	
			}else{
				async_comm3(x, y+1, z, flag, pos, yMatrix1);	
			}

			/************************z-axle***************************************/
			Double2DMatrix zMatrix0, zMatrix1;
			zMatrix0.resize(n1);
			zMatrix1.resize(n1);
			for(int i=0; i<n1; i++){
				zMatrix0[i].resize(n2);
				zMatrix1[i].resize(n2);
			}

			for(int i1=1; i1<n1-1; i1++){
				for(int i2=1; i2<n2-1; i2++){
					zMatrix0[i1][i2] = u[i1][i2][1];
					zMatrix1[i1][i2] = u[i1][i2][n3-2];
				}	
			}

			pos.x = 0;
			pos.y = 0;
			pos.z = 1;
			if(z == 0){
				async_comm3(x, y, unit_num-1, flag, pos, zMatrix0);	
			}else{
				async_comm3(x, y, z-1, flag, pos, zMatrix0);	
			}

			pos.z = -1;
			if(z == unit_num-1){
				async_comm3(x, y, 0, flag, pos, zMatrix1);	
			}else{
				async_comm3(x, y, z+1, flag, pos, zMatrix1);	
			}

			/************************xy-line***************************************/
			Doule2DMatrix xyMatrix;
			xyMatrix.resize(4);
			for(int i=0; i<4; i++){
				xyMatrix[i].resize(n3);	
			}

			for(int i3=1; i3<n3-1; i3++){
				xyMatrix[0][i3] = u[1][1][i3];
				xyMatrix[1][i3] = u[1][n2-2][i3];
				xyMatrix[2][i3] = u[n1-2][1][i3];
				xyMatrix[3][i3] = u[n1-2][n2-2][i3];
			}

		
			for(int p1=-1; p1<=1; p1+=2){
				for(int p2=-1; p2<=1; p2+=2){
					Position target;
					target.x = (x+p1)%unit_num;
					target.y = (y+p2)%unit_num;
					target.z = z;

					pos.x = -p1;
					pos.y = -p2;
					pos.z = 0;

					if(p1 == -1 && p2 == -1){
						async_comm2(target.x, target.y, target.z, flag, pos, xyMatrix[0]);	
					}else if(p1 == -1 && p2 == 1){
						async_comm2(target.x, target.y, target.z, flag, pos, xyMatrix[1]);	
					}else if(p1 == 1 && p2 == -1){
						async_comm2(target.x, target.y, target.z, flag, pos, xyMatrix[2]);	
					}else{
						async_comm2(target.x, target.y, target.z, flag, pos, xyMatrix[3]);
					}

				}	
			}
		
			/************************xz-line***************************************/
			Doule2DMatrix xzMatrix;
			xzMatrix.resize(4);
			for(int i=0; i<4; i++){
				xzMatrix[i].resize(n2);	
			}

			for(int i2=1; i2<n2-1; i2++){
				xzMatrix[0][i2] = u[1][i2][1];
				xzMatrix[1][i2] = u[1][i2][n3-2];
				xzMatrix[2][i2] = u[n1-2][i2][1];
				xzMatrix[3][i2] = u[n1-2][i2][n3-2];
			}

			for(int p1=-1; p1<=1; p1+=2){
				for(int p3=-1; p3<=1; p3+=2){
					Position target;
					target.x = (x+p1)%unit_num;
					target.y = y;
					target.z = (z+p3)%unit_num;

					pos.x = -p1;
					pos.y = 0;
					pos.z = -p3;

					if(p1 == -1 && p3 == -1){
						async_comm2(target.x, target.y, target.z, flag, pos, xzMatrix[0]);	
					}else if(p1 == -1 && p3 == 1){
						async_comm2(target.x, target.y, target.z, flag, pos, xzMatrix[1]);	
					}else if(p1 == 1 && p3 == -1){
						async_comm2(target.x, target.y, target.z, flag, pos, xzMatrix[2]);	
					}else{
						async_comm2(target.x, target.y, target.z, flag, pos, xzMatrix[3]);
					}

				}	
			}

			/************************yz-line***************************************/
			Doule2DMatrix yzMatrix;
			yzMatrix.resize(4);
			for(int i=0; i<4; i++){
				yzMatrix[i].resize(n1);	
			}

			for(int i1=1; i1<n1-1; i1++){
				yzMatrix[0][i1] = u[i1][1][1];
				yzMatrix[1][i1] = u[i1][1][n3-2];
				yzMatrix[2][i1] = u[i1][n2-2][1];
				yzMatrix[3][i1] = u[i1][n2-2][n3-2];
			}

			for(int p2=-1; p2<=1; p2+=2){
				for(int p3=-1; p3<=1; p3+=2){
					Position target;
					target.x = x;
					target.y = (y+p2)%unit_num;
					target.z = (z+p3)%unit_num;

					pos.x = 0;
					pos.y = -p2;
					pos.z = -p3;

					if(p2 == -1 && p3 == -1){
						async_comm2(target.x, target.y, target.z, flag, pos, yzMatrix[0]);	
					}else if(p2 == -1 && p3 == 1){
						async_comm2(target.x, target.y, target.z, flag, pos, yzMatrix[1]);	
					}else if(p2 == 1 && p3 == -1){
						async_comm2(target.x, target.y, target.z, flag, pos, yzMatrix[2]);	
					}else{
						async_comm2(target.x, target.y, target.z, flag, pos, yzMatrix[3]);
					}

				}	
			}

			/*****************************xyz-angle***************************************/
			DoubleArray xyzArray;
			xyzArray.resize(8);

			xyzArray[0] = u[1][1][1];
			xyzArray[1] = u[1][1][n3-2];
			xyzArray[2] = u[1][n2-2][1];
			xyzArray[3] = u[1][n2-2][n3-2];
			xyzArray[4] = u[n1-2][1][1];
			xyzArray[5] = u[n1-2][1][n3-2];
			xyzArray[6] = u[n1-2][n2-2][1];
			xyzArray[7] = u[n1-2][n2-2][n3-2];

			int iter = 0;
			for(int p1=-1; p1<=1; p1+=2){
				for(int p2=-1; p2<=1; p2+=2){
					for(int p3=-1; p3<=1; p3+=2){
							Position target;
							target.x = (x+p1)%unit_num;
							target.y = (y+p2)%unit_num;
							target.z = (z+p3)%unit_num;

							pos.x = -p1;
							pos.y = -p2;
							pos.z = -p3;

							async_comm1(target.x, target.y, target.z, flag, pos, xyzArray[iter++]);
					}	
				}	
			}
			

	}


	[unit<x, y, z>] void resid(int& x, int& y, int& z, Double3DMatrix& u, Double3DMatrix& v, Double3DMatrix& r, 
			int& n1, int& n2, int& n3){
		int i3,  i2,  i1;
		DoubleArray u1, u2;
		u1.resize(nm+1);
		u2.resize(nm+1);
											
		for(i3=1;i3<n3-1;i3++)
			for(i2=1;i2<n2-1;i2++){
				for(i1=0;i1<n1;i1++){
					u1[i1] = u[i1][i2-1][i3] + u[i1][i2+1][i3] + u[i1][i2][i3-1] + u[i1][i2][i3+1];
					u2[i1] = u[i1][i2-1][i3-1] + u[i1][i2+1][i3-1] + u[i1][i2-1][i3+1] + u[i1][i2+1][i3+1];
				}
				
				for(i1=1;i1<n1-1;i1++){
					r[i1][i2][i3] = v[i1][i2][i3] - a[0] * u[i1][i2][i3] - a[2] * ( u2[i1] + u1[i1-1] + u1[i1+1] ) 
												- a[3] * ( u2[i1-1] + u2[i1+1] );
				}
			}
	}

}


