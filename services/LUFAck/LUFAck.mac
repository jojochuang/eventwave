/*
01/12/2012
LUFAck is based on LUFactorization service, but with message acknowledge to prevent process migration & do failure recovery.
*/
service LUFAck;
 
typedefs {
    typedef mace::vector< mace::vector<double> > Matrix;
}
services {
    Transport tcp = TcpTransport();
}
 
states{
   compute;
}

constants {
    int32_t DEFAULT_ROWS    =   5;
    int32_t DEFAULT_COLUMNS =   5;
    uint64_t RESEND_PERIOD = 1*100*1000; // Period between each resend 0.1 second
}
/**
chuangw:
to change default parameter values to foo, in parameters.default, set
ServiceConfig.LUFResending.ROWS = foo and
ServiceConfig.LUFResending.COLUMNS = foo
*/
constructor_parameters {
    int32_t ROWS = DEFAULT_ROWS;
    int32_t COLUMNS = DEFAULT_COLUMNS;
}
 
state_variables {
   Matrix initial_matrix;
   uint32_t rows;
   uint32_t columns;

   uint32_t current_iteration;
   uint32_t init_cells;
   uint32_t finished_row;
   context Row<uint32_t ROWS>{ 
      uint32_t finished_cell;
      context Column<uint32_t COLUMNS>{
         double value;
         double pivot_val;
      }
   }

    // the following should be generated by compiler.
   uint64_t msgseqno;
   mace::map<mace::MaceKey, mace::map<uint64_t, mace::string> > unAcked;
   mace::map<mace::MaceKey, uint64_t> smallestAckedSeqNo;

   timer resend_timer __attribute((recur(RESEND_PERIOD)));
 
   mace::map<mace::MaceKey,int> resendNode;
}
// implicitly declare x,y as state variable of the context
 
messages{
    async_cellInit_param{uint32_t row; uint32_t column; double initial_val; uint64_t seqno;}
    async_cellInitDone_param{uint32_t __unused; uint64_t seqno;}
    async_startIteration_param{ uint32_t row; uint32_t current_iteration; uint64_t seqno;}
    async_startIterationPivot_param{ uint32_t row; uint32_t current_iteration; uint64_t seqno;}
    async_updateRightward_param{uint32_t row; uint32_t column; int pivot; uint64_t seqno;}
    async_updateDownward_param{uint32_t row;uint32_t column; int topVal; uint64_t seqno;}
    async_cellDone_param{uint32_t row; uint64_t seqno;}
    async_rowDone_param{uint32_t __unused; uint64_t seqno;}

    Ack{ uint64_t seqno; }

}

transitions {
    // in full context model, maceInit() is only ran by global context node.
    // XXX: I am making every node to execute maceInit
   //downcall (state == init)maceInit()  {
   downcall maceInit()  {

    if( ContextMapping::getNodeByContext("") == localAddress()) {
          rows = ROWS;
          columns = COLUMNS;
          initial_matrix.resize( rows );
          for(uint32_t i=0;i< rows;i++){
              initial_matrix[i].resize( columns );
          }
     
          current_iteration = 0;
          finished_row = 0;
          init_cells = 0;
     
          for( uint32_t i=0;i< rows; i++ ){
              for( uint32_t j=0;j<columns;j++){
                 //async_cellInit(i,j,initial_matrix[i][j]);
                 async_cellInit_param msg( i,j,initial_matrix[i][j],msgseqno );
                 mace::string serialized_msg;
                 mace::serialize(serialized_msg, &msg);
                 storeUnacked( ContextMapping::getHead(), serialized_msg );
                 downcall_route(  ContextMapping::getHead(), msg );
              }
          }
          // FIXME: state is a special global variable. I have not yet known how to deal with it.
          //state = compute;
      }
         
      resend_timer.reschedule( RESEND_PERIOD );
   }
       
    upcall deliver(const MaceKey& from, const MaceKey& dest, const async_cellInit_param& msg) {
        // 
        uint64_t& ackedseqno = smallestAckedSeqNo[from];
        if( msg.seqno < smallestAckedSeqNo[from] ){
            maceout<<"received a message, seq="<<msg.seqno<<" from "<<from<<". But smallestAckedSeqNo="<<ackedseqno<<", so drop it"<<Log::endl;
            // drop, ignore, discard
            return;
        }
        // update smallestAckedSeqNo;
        // ackedseqno++;
        downcall_route( from, Ack(msg.seqno) );

        mace::ContextLock cl( Row[msg.row].Column[msg.column], mace::ContextLock::WRITE_MODE );
        mace::string destContextID = "Row["+boost::lexical_cast<std::string>(msg.row)+"]Column["+boost::lexical_cast<std::string>(msg.column)+"]";
        MaceKey node = ContextMapping::getNodeByContext(destContextID);
        if( ContextMapping::getHead() == localAddress() ){
            mace::string serialized_msg;
            mace::serialize(serialized_msg, &msg);
            storeUnacked( node, serialized_msg );
            downcall_route( node, msg );
        }else if( node == localAddress() ){
            Row[msg.row].Column[msg.column].value = msg.initial_val; 

            //async_cellInitDone();
            async_cellInitDone_param nmsg(0 ,msgseqno );
            mace::string serialized_nmsg;
            mace::serialize(serialized_nmsg, &nmsg);
            storeUnacked( ContextMapping::getHead(), serialized_nmsg );
            downcall_route(  ContextMapping::getHead(), nmsg );
        }
    }
   /*async  [Row<row>::Column<column>](state==init)cellInit( uint32_t row, uint32_t column, uint32_t initial_val ) [locking=read]  {
      maceout<<"cellInit(row="<<row<<",column="<<column<<",initial_val="<<initial_val<<Log::endl;
      Row[row].Column[column].value = initial_val; 

      async_cellInitDone();
   }*/
    upcall deliver(const MaceKey& from, const MaceKey& dest, const async_cellInitDone_param& msg) {

        uint64_t& ackedseqno = smallestAckedSeqNo[from];
        if( msg.seqno < smallestAckedSeqNo[from] ){
            maceout<<"received a message, seq="<<msg.seqno<<" from "<<from<<". But smallestAckedSeqNo="<<ackedseqno<<", so drop it"<<Log::endl;
            // drop, ignore, discard
            return;
        }
        // update smallestAckedSeqNo;
        // ackedseqno++;
        downcall_route( from, Ack(msg.seqno) );

        mace::ContextLock cl( mace::ContextBaseClass::globalContext, mace::ContextLock::WRITE_MODE );
        mace::string destContextID = ""; // global
        MaceKey node = ContextMapping::getNodeByContext(destContextID);
        if( ContextMapping::getHead() == localAddress() ){
            mace::string serialized_msg;
            mace::serialize(serialized_msg, &msg);
            storeUnacked( node, serialized_msg );
            downcall_route( node, msg );
        }else if( node == localAddress() ){
            init_cells++;

            if( init_cells == rows*columns){
                for( uint32_t i=0;i< rows; i++ ){
                    //async_startIteration( i, current_iteration );
                    async_startIteration_param nmsg(i, current_iteration ,msgseqno );
                    mace::string serialized_nmsg;
                    mace::serialize(serialized_nmsg, &nmsg);
                    storeUnacked( ContextMapping::getHead(), serialized_nmsg );
                    downcall_route(  ContextMapping::getHead(), nmsg );
                }
            }
        }
    }
   /*async cellInitDone(){
      init_cells++;
      if( init_cells == rows*columns){
          for( uint32_t i=0;i< rows; i++ )
              async_startIteration( i, current_iteration );
      }
   }*/
    upcall deliver(const MaceKey& from, const MaceKey& dest, const async_startIteration_param& msg) {

        uint64_t& ackedseqno = smallestAckedSeqNo[from];
        if( msg.seqno < smallestAckedSeqNo[from] ){
            maceout<<"received a message, seq="<<msg.seqno<<" from "<<from<<". But smallestAckedSeqNo="<<ackedseqno<<", so drop it"<<Log::endl;
            // drop, ignore, discard
            return;
        }
        // update smallestAckedSeqNo;
        // ackedseqno++;
        downcall_route( from, Ack(msg.seqno) );

        mace::ContextLock cl( Row[msg.row], mace::ContextLock::WRITE_MODE );
        mace::string destContextID = "Row["+boost::lexical_cast<std::string>(msg.row)+"]"; // global
        MaceKey node = ContextMapping::getNodeByContext(destContextID);
        if( ContextMapping::getHead() == localAddress() ){
            mace::string serialized_msg;
            mace::serialize(serialized_msg, &msg);
            storeUnacked( node, serialized_msg );
            downcall_route( node, msg );
        }else if( node == localAddress() ){
            Row[msg.row].finished_cell = 0;
            //async_startIterationPivot(row, current_iteration);
            async_startIterationPivot_param nmsg(msg.row, current_iteration ,msgseqno );
            mace::string serialized_nmsg;
            mace::serialize(serialized_nmsg, &nmsg);
            storeUnacked( ContextMapping::getHead(), serialized_nmsg );
            downcall_route(  ContextMapping::getHead(), nmsg );
        }
    }
   /*async [Row<row>](state==compute)startIteration( uint32_t row, uint32_t current_iteration )  {
      maceout<<"startIteration(row="<<row<<",current_iteration="<<current_iteration<<Log::endl;
      Row[row].finished_cell = 0;
      async_startIterationPivot(row, current_iteration);
   }*/
    upcall deliver(const MaceKey& from, const MaceKey& dest, const async_startIterationPivot_param& msg) {

        uint64_t& ackedseqno = smallestAckedSeqNo[from];
        if( msg.seqno < smallestAckedSeqNo[from] ){
            maceout<<"received a message, seq="<<msg.seqno<<" from "<<from<<". But smallestAckedSeqNo="<<ackedseqno<<", so drop it"<<Log::endl;
            // drop, ignore, discard
            return;
        }
        // update smallestAckedSeqNo;
        // ackedseqno++;
        downcall_route( from, Ack(msg.seqno) );

        mace::string destContextID = "Row["+boost::lexical_cast<std::string>(msg.row)+"]Column["+boost::lexical_cast<std::string>(msg.current_iteration)+"]";
        MaceKey node = ContextMapping::getNodeByContext(destContextID);
        if( ContextMapping::getHead() == localAddress() ){
            mace::string serialized_msg;
            mace::serialize(serialized_msg, &msg);
            storeUnacked( node, serialized_msg );
            downcall_route( node, msg );
        }else if( node == localAddress() ){
            for( uint32_t k=msg.current_iteration+1; k<columns;k++ ){
                //async_updateRightward(msg.row,k,Row[msg.row].Column[msg.current_iteration].value);
                async_updateRightward_param nmsg(msg.row,k,Row[msg.row].Column[msg.current_iteration].value,msgseqno);
                mace::string serialized_msg;
                mace::serialize(serialized_msg, &nmsg);
                storeUnacked( ContextMapping::getHead(), serialized_msg );
                downcall_route(  ContextMapping::getHead(), nmsg );
            }
            if( msg.row == msg.current_iteration )
               Row[msg.row].Column[msg.current_iteration].value = 1.0;
            else
               Row[msg.row].Column[msg.current_iteration].value = 0.0;
        }
    }
   /*async [Row<row>::Column<current_iteration>] (state==compute)startIterationPivot( uint32_t row, uint32_t current_iteration )  {
      for( uint32_t k=current_iteration+1; k<columns;k++ ){
          async_updateRightward(row,k,Row[row].Column[current_iteration].value);
      }
      if( row == current_iteration )
         Row[row].Column[current_iteration].value = 1.0;
      else
         Row[row].Column[current_iteration].value = 0.0;
   }*/
    upcall deliver(const MaceKey& from, const MaceKey& dest, const async_updateRightward_param& msg) {

        uint64_t& ackedseqno = smallestAckedSeqNo[from];
        if( msg.seqno < smallestAckedSeqNo[from] ){
            maceout<<"received a message, seq="<<msg.seqno<<" from "<<from<<". But smallestAckedSeqNo="<<ackedseqno<<", so drop it"<<Log::endl;
            // drop, ignore, discard
            return;
        }
        // update smallestAckedSeqNo;
        // ackedseqno++;
        downcall_route( from, Ack(msg.seqno) );

        mace::string destContextID = "Row["+boost::lexical_cast<std::string>(msg.row)+"]Column["+boost::lexical_cast<std::string>(msg.column)+"]";
        MaceKey node = ContextMapping::getNodeByContext(destContextID);
        if( ContextMapping::getHead() == localAddress() ){
            mace::string serialized_msg;
            mace::serialize(serialized_msg, &msg);
            storeUnacked( node, serialized_msg );
            downcall_route( node, msg );
        }else if( node == localAddress() ){
            if( msg.row == current_iteration ){
                Row[msg.row].Column[msg.column].value /= msg.pivot;
                for( uint32_t r=msg.row+1; r< rows;r++){
                    //async_updateDownward(r, msg.column, Row[msg.row].Column[msg.column].value);
                    async_updateDownward_param nmsg(r, msg.column, Row[msg.row].Column[msg.column].value,msgseqno);
                    mace::string serialized_msg;
                    mace::serialize(serialized_msg, &nmsg);
                    storeUnacked( ContextMapping::getHead(), serialized_msg );
                    downcall_route(  ContextMapping::getHead(), nmsg );
                }
            }else{
                Row[msg.row].Column[msg.column].pivot_val = msg.pivot;
            }
        }
    }
   /*async [Row<row>::Column<column>] updateRightward(uint32_t row, uint32_t column, int pivot) {
      if( row == current_iteration ){
          Row[row].Column[column].value /= pivot;
          for( uint32_t r=row+1; r< rows;r++)
              async_updateDownward(r, column, Row[row].Column[column].value);
      }else{
          Row[row].Column[column].pivot_val = pivot;
      }
   }*/
    upcall deliver(const MaceKey& from, const MaceKey& dest, const async_updateDownward_param& msg) {

        uint64_t& ackedseqno = smallestAckedSeqNo[from];
        if( msg.seqno < smallestAckedSeqNo[from] ){
            maceout<<"received a message, seq="<<msg.seqno<<" from "<<from<<". But smallestAckedSeqNo="<<ackedseqno<<", so drop it"<<Log::endl;
            // drop, ignore, discard
            return;
        }
        // update smallestAckedSeqNo;
        // ackedseqno++;
        downcall_route( from, Ack(msg.seqno) );

        mace::string destContextID = "Row["+boost::lexical_cast<std::string>(msg.row)+"]Column["+boost::lexical_cast<std::string>(msg.column)+"]";
        MaceKey node = ContextMapping::getNodeByContext(destContextID);
        if( ContextMapping::getHead() == localAddress() ){
            mace::string serialized_msg;
            mace::serialize(serialized_msg, &msg);
            storeUnacked( node, serialized_msg );
            downcall_route( node, msg );
        }else if( node == localAddress() ){
            Row[msg.row].Column[msg.column].value -= Row[msg.row].Column[msg.column].pivot_val * msg.topVal;
            //async_cellDone( row );
            async_cellDone_param nmsg(msg.row,msgseqno);
            mace::string serialized_msg;
            mace::serialize(serialized_msg, &nmsg);
            storeUnacked( ContextMapping::getHead(), serialized_msg );
            downcall_route(  ContextMapping::getHead(), nmsg );
        }
    }
   /*async [Row<row>::Column<column>] updateDownward(uint32_t row,uint32_t column, int topVal)  {
      Row[row].Column[column].value -= Row[row].Column[column].pivot_val * topVal;
      async_cellDone( row );
   }*/
    upcall deliver(const MaceKey& from, const MaceKey& dest, const async_updateDownward_param& msg) {

        uint64_t& ackedseqno = smallestAckedSeqNo[from];
        if( msg.seqno < smallestAckedSeqNo[from] ){
            maceout<<"received a message, seq="<<msg.seqno<<" from "<<from<<". But smallestAckedSeqNo="<<ackedseqno<<", so drop it"<<Log::endl;
            // drop, ignore, discard
            return;
        }
        // update smallestAckedSeqNo;
        // ackedseqno++;
        downcall_route( from, Ack(msg.seqno) );

        mace::string destContextID = "Row["+boost::lexical_cast<std::string>(msg.row)+"]";
        MaceKey node = ContextMapping::getNodeByContext(destContextID);
        if( ContextMapping::getHead() == localAddress() ){
            mace::string serialized_msg;
            mace::serialize(serialized_msg, &msg);
            storeUnacked( node, serialized_msg );
            downcall_route( node, msg );
        }else if( node == localAddress() ){
            if( ++Row[msg.row].finished_cell == columns - current_iteration - 1){
              Row[msg.row].finished_cell = 0;
              //async_rowDone();
              async_rowDone_param nmsg(0,msgseqno);
              mace::string serialized_msg;
              mace::serialize(serialized_msg, &nmsg);
              storeUnacked( ContextMapping::getHead(), serialized_msg );
              downcall_route(  ContextMapping::getHead(), nmsg );
            }
        }
    }
   /*async [Row<row>]cellDone(uint32_t row)   {
      if( ++Row[row].finished_cell == columns - current_iteration - 1){
        Row[row].finished_cell = 0;
        async_rowDone();
      }
   }*/
    upcall deliver(const MaceKey& from, const MaceKey& dest, const async_rowDone_param& msg) {

        uint64_t& ackedseqno = smallestAckedSeqNo[from];
        if( msg.seqno < smallestAckedSeqNo[from] ){
            maceout<<"received a message, seq="<<msg.seqno<<" from "<<from<<". But smallestAckedSeqNo="<<ackedseqno<<", so drop it"<<Log::endl;
            // drop, ignore, discard
            return;
        }
        // update smallestAckedSeqNo;
        // ackedseqno++;
        downcall_route( from, Ack(msg.seqno) );

        mace::string destContextID = ""; //global
        MaceKey node = ContextMapping::getNodeByContext(destContextID);
        if( ContextMapping::getHead() == localAddress() ){
            mace::string serialized_msg;
            mace::serialize(serialized_msg, &msg);
            storeUnacked( node, serialized_msg );
            downcall_route( node, msg );
        }else if( node == localAddress() ){
            if( ++ finished_row == rows ){
               finished_row = 0;
               current_iteration++;
               for( uint32_t i=current_iteration;i< rows; i++ ){
                   //async_startIteration( i, current_iteration );
                   async_startIteration_param nmsg(i, current_iteration,msgseqno);
                   mace::string serialized_msg;
                   mace::serialize(serialized_msg, &nmsg);
                   storeUnacked( ContextMapping::getHead(), serialized_msg );
                   downcall_route(  ContextMapping::getHead(), nmsg );
               }
            }
        }
    }
   /*async  rowDone(){
      if( ++ finished_row == rows ){
         finished_row = 0;
         current_iteration++;
         for( uint32_t i=current_iteration;i< rows; i++ )
             async_startIteration( i, current_iteration );
      }
   }*/
  upcall error(const MaceKey& nodeId, TransportError::type error_code, const std::string& m, registration_uid_t registrationUid) {
  }
  scheduler  resend_timer (){
    for( mace::map<MaceKey,int>::iterator it=resendNode.begin(); it!= resendNode.end(); it++ ){
        const MaceKey& nodeId = it->first;
        mace::map<uint64_t, mace::string>& msgs = unAcked[nodeId];
        maceout<<"I have "<< msgs.size() <<" unacked messages"<<Log::endl;
        int c=0;
        for( mace::map<uint64_t, mace::string>::iterator im= msgs.begin(); im != msgs.end(); im++,c++){
            maceout<<"resending message "<<c<<Log::endl;
            std::istringstream in( im->second );
            switch( Message::getType( im->second) ){
                case Ack::messageType:{
                    Ack msg;
                    mace::deserialize( in, &msg);
                    downcall_route( nodeId, msg );
                }
                    break;
                case async_cellInit_param::messageType:{
                    async_cellInit_param msg;
                    mace::deserialize( in, &msg);
                    downcall_route( nodeId, msg );
                }
                    break;
                case async_cellInitDone_param::messageType:{
                    async_cellInitDone_param msg;
                    mace::deserialize( in, &msg);
                    downcall_route( nodeId, msg );
                }
                    break;
                case async_startIteration_param::messageType:{
                    async_startIteration_param msg;
                    mace::deserialize( in, &msg);
                    downcall_route( nodeId, msg );
                }
                    break;
                case async_startIterationPivot_param::messageType:{
                    async_startIterationPivot_param msg;
                    mace::deserialize( in, &msg);
                    downcall_route( nodeId, msg );
                }
                    break;
                case async_updateRightward_param::messageType:{
                    async_updateRightward_param msg;
                    mace::deserialize( in, &msg);
                    downcall_route( nodeId, msg );
                }
                    break;
                case async_updateDownward_param::messageType:{
                    async_updateDownward_param msg;
                    mace::deserialize( in, &msg);
                    downcall_route( nodeId, msg );
                }
                    break;
                case async_cellDone_param::messageType:{
                    async_cellDone_param msg;
                    mace::deserialize( in, &msg);
                    downcall_route( nodeId, msg );
                }
                    break;
                case async_rowDone_param::messageType:{
                    async_rowDone_param msg;
                    mace::deserialize( in, &msg);
                    downcall_route( nodeId, msg );
                }
                    break;
                default:{
                    maceerr<<"unrecognized message type id: "<<Message::getType( im->second)<<Log::endl;
                }
            }
        }
      }
  }
}
routines{
    void storeUnacked( const MaceKey& dest, const mace::string& msg ){
        mace::ContextLock cl( mace::ContextBaseClass::globalContext, mace::ContextLock::WRITE_MODE );

        unAcked[dest][msgseqno] = msg;
        msgseqno ++;
    }
}
