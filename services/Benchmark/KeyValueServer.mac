#include <functional>
#define get16bits(d) ((((uint32_t)(((const uint8_t *)(d))[1])) << 8)\
                       +(uint32_t)(((const uint8_t *)(d))[0]) )

service KeyValueServer;

provides Null, MigrationTest;

time = MaceTime;

constructor_parameters {
  //NodeSet CHAT_NODES = NodeSet();
  uint32_t NUM_GROUPS = 0;
}

services {
  Transport t;
}

messages {
  Get __attribute((number(0))){
		uint32_t worker_id;
    mace::string key;
  }
  GetReply {
		uint32_t worker_id;
		bool get_flag;
    bool exists;
    mace::string key;
    mace::string value;
  }
  Put {
		uint32_t worker_id;
    mace::string key;
    mace::string value;
  }
}

state_variables {
  uint32_t num_groups;
  context Bucket<uint32_t bucket_id> {
    mace::map<mace::string, mace::string> kvmap;
  }
}

local_address {
  return downcall_localAddress();
}


transitions {
  downcall maceInit() {
    ADD_SELECTORS("KeyValueServer");
  }

  upcall deliver(const MaceKey& src, const MaceKey& dest, const Get& msg) {
    async_get( get_bucket(msg.key), src, msg.key, msg.worker_id );
  }

  upcall deliver(const MaceKey& src, const MaceKey& dest, const Put& msg) {
    async_put( get_bucket(msg.key), src, msg.key, msg.value, msg.worker_id );
  }

  async [Bucket<id>] get(const uint32_t id, const MaceKey &src, const mace::string& key, const uint32_t& worker_id) {
    if( kvmap.find(key) != kvmap.end() ) {
      downcall_route(src, GetReply(worker_id, true, true, key, kvmap[key]));
    } else {
      downcall_route(src, GetReply(worker_id, true, false, key, "NULL"));
    }
  }

  async [Bucket<id>] put(const uint32_t id, const MaceKey &src, const mace::string& key, const mace::string& value, const uint32_t& worker_id) {
    kvmap[key] = value;
		downcall_route(src, GetReply(worker_id, false, true, key, value));
  }
}


routines {
  /*
   * Refer to http://www.azillionmonkeys.com/qed/hash.html */
  uint32_t get_bucket(const mace::string& key) {
    uint32_t len = key.length();
    char * cstr = new char [key.length()+1];
    char * data = cstr;
    uint32_t hash = len, tmp;
    int rem;

    if (len == 0) {
      delete[] cstr;
      return 0;
    }

    rem = len & 3;
    len >>= 2;

    /* Main loop */
    for (; len > 0; len--) {
      hash  += get16bits (data);
      tmp    = (get16bits (data+2) << 11) ^ hash;
      hash   = (hash << 16) ^ tmp;
      data  += 2*sizeof (uint16_t);
      hash  += hash >> 11;
    }

    /* Handle end cases */
    switch (rem) {
      case 3: hash += get16bits (data);
              hash ^= hash << 16;
              hash ^= ((signed char)data[sizeof (uint16_t)]) << 18;
              hash += hash >> 11;
              break;
      case 2: hash += get16bits (data);
              hash ^= hash << 11;
              hash += hash >> 17;
              break;
      case 1: hash += (signed char)*data;
              hash ^= hash << 10;
              hash += hash >> 1;
    }

    /* Force "avalanching" of final 127 bits */
    hash ^= hash << 3;
    hash += hash >> 5;
    hash ^= hash << 4;
    hash += hash >> 17;
    hash ^= hash << 25;
    hash += hash >> 6;

    delete[] cstr;
    return hash % (NUM_GROUPS);

    //std::hash<const char*> H;
    //return ((uint32_t) H(key.c_str())) % (NUM_GROUPS);
  }
}


