#include "mmultimap.h"
#include "message.mi"

service FullCtxPaxos;

provides Consensus;

trace=high;

services {
  //use the TCP protocal to sent the msg
  Transport t = auto(shared,[reliable],[]);
}

constants {
  
}

constructor_parameters {
 
}

states {
  
}

typedefs {

}

messages {
  	AcceptorPromise {
				uint64_t proposer;
				uint64_t proposeID;
				Value value;
		}

		AcceptorLearnMsg {
				Value value;	
		}
}


state_variables {
		mace::queue<uint64_t> learners;
		mace::map<uint64_t, MaceKey> logicalNodeMap;

		context Acceptor {
				uint64_t confirmedMaxID;
				Value curValue;
				
		}

}

transitions {
  	downcall (state == init) maceInit() {
    
		}
      
  

		async [Acceptor] prepare( uint64_t proposeID, Value& value ){
				if(proposeID > confirmedMaxID){
						confirmedMaxID = proposeID;
						curValue = value;
						downcall_route( ContextMapping::getHead(), AcceptorPromise(proposeID, value) );
				}	
		}

		async [Acceptor] accept( Value value ){
				if(value.key == curValue.key){
						downcall_route( ContextMapping::getHead(), AcceptorLearnMsg(value));
						value.key = "";
				}				
    }

		upcall void deliver(const MaceKey& src,  const MaceKey& dest,  const Prepare& m){
				async_prepare( m.proposeID, m.value );	
		}

		upcall void deliver(const MaceKey& src,  const MaceKey& dest,  const Accept& m){
				async_accept( m.value );	
		}

		upcall void deliver(const MaceKey& src,  const MaceKey& dest,  const AcceptorLearnMsg& m){
				mace::queue<uint64_t>::iterator learnerIter = learners.begin();
				while( learnerIter != learners.end()){
						downcall_route( logicalNodeMap[*learnerIter], Learn(m.value) );
				}
		}

		upcall void deliver( const MaceKey& src, const MAceKey& dest, const AcceptorPromise& m){
				downcall_route( getProposer(), Promise(m.proposeID, m.value) );	
		}
}
