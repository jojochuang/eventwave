#include "mset.h"
 

service Tag;
 
provides Tag;
 
services {
  Transport t = auto(shared,[reliable,inorder],[]);
}
 
constants {
  //the maximum time that a child can stay in the same spot

  uint16_t BREAKTIME = 10 * 1000;
  //the maximum size that a room can have
  uint16_t MAXIMUMSIZE = 20;

}
 
states {
  //after all the contexts have been initialized, the state change to ready
  ready;
}
 
messages {
  //the player send this message to check the number of kid in a specific room
  CheckKidNum {
    uint16_t nBuilding;
    uint16_t nRoom;
  }
  //the server send back the number by using this reply message
  KidNumReply {
    uint16_t kidNum;
  }
  //when in the aisle, the player can send a room change request to change room
  ChangeRoom {
    uint16_t originBuilding;
    uint16_t nBuilding;
    uint16_t nRoom;
    uint16_t kidID;
  }
  //change the direction of a kid
  ChangeDirection {
    uint16_t newDirection;
    uint16_t kidID;
  }
  //the requeset when a player want to join the game
  RequireInitial {

  }
  //reply the request with the id and the role
  ReceiveInitial {
    uint16_t role;
    uint16_t id;
  }
  //the position require message sent by client
  RequirePosition {
    uint16_t kidID;
    uint16_t nBuilding;
    uint16_t nRoom;
  }
  //reply to the message with  the current position
  ReceivePosition {
    uint16_t x_coordinate;
    uint16_t y_coordinate;
    uint16_t roomMap;
  }
  //the require message sent by the client
  RequireRoomInfo {
    uint16_t nBuilding;
    uint16_t nRoom;
  }
  //send back the room map as a reply
  ReceiveRoomInfo {
    uint16_t length;
    uint16_t width;
    uint16_t map[MAXIMUMSIZE][MAXIMUMSIZE];
  }
}
 
state_variables {
  context Global {
    int kidCounter = 0;
  }
  //indicates the hierachy structure of the world
  context Building <uint16_t nBuilding> {
    context Room <uint16_t nRoom> {
      //a set contains all the IDs in this room
      mace::set<uint16_t> kidsInRoom;
      //indicates the boundary of a room
      uint16_t length;
      uint16_t width;
      //use a matrix as a grid to keep track of the kids' location within this room
      //'-1' means no one in that spot, the other number implies the kidID
      int kidsMap[MAXIMUMSIZE][MAXIMUMSIZE] = {-1};
    }
    //aisle is special place for transtions
    //"it" can't tag kids in aisle
    context Aisle {
      //a set contains all the IDs in this aisle
      mace::set<uint16_t> kidsInAisle;
    }
  }
  context Kid <uint16_t nKid> {
    //indicate that if the kid is "it"
    uint16_t roleStatus;
    //indicates the ID of a kid
    uint16_t kidID;
    //indicate if the kid is in the aisle or in the room
    //0 represent the "Room", 1 represent the "Aisle"
    int location;
    //indicates the location of the kids
    uint16_t currentBuilding;
    uint16_t currentRoom;
    uint16_t x_coordinate;
    uint16_t y_coordinate;
    //indicates the boudary of the room that the kid currently stayed
    uint16_t xRoom;
    uint16_t yRoom;
    //the timer that controls the movement of the child
    timer kidRun;
    //indicates the direction that a kid runs
    //'0' is not move, '1','2','3','4' means up, down, left, right
    uint16_t kidDirection;
    //potential attributes
    //avatar
  }
}

transitions {
  //check the syntax for hierachy context
  downcall (state == init) maceInit() {
    //the context can be only initialized in the global context

    int nBuilding = 2, nRoom = 2;
    //initialize state variables and contexts here
    for (int i = 0; i < nBuilding; i++) {
      sync_buildingInit(i);
      for (int j = 0; j < nRoom; j++) {
          sync_roomInitial(i, j);

      }
    }

  } 

 
  //definition of worldInit
  [Kid<nKid>] kidInit (int nKid, const MaceKey& src) {
  /*sync [Kid<nKid>] kidInit (int nKid) {*/
    roleStatus = 0;
    kidID = nKid;
    x_coordinate = 0;
    y_coordinate = 0;
    currentBuilding = 0;
    currentRoom = 0;
    xRoom = 10;
    yRoom = 10;
    //set the timer

    kidRun.reschedule(BREAKTIME, id);
    kidDirection = 0;
    //put every one in aisle when initialize the game
    location = 1;
    downcall_route(src, ReceiveInitial(0, kidID));

  }

  //need a global variable to keep track of the kidID that has been initialized
  [Global] kidInitial (const MaceKey& src) {
    async_kidInit(kidCounter++, src);
  }

  //definition of buildingInit
  [Building<nBuilding>] buildingInit(uint16_t nBuilding) {
  /*sync [Building<nBuilding>] buildingInit(uint16_t nBuilding) {*/
    //initial the variables in building  
  }
 
  //definition of roomInit

  [Building<nBuilding>::Room<nRoom>] roomInit(uint16_t nBuilding, uint16_t nRoom) {
  /*sync [Building<nBuilding>::Room<nRoom>] roomInit(uint16_t nBuilding, uint16_t nRoom) {*/

    length = 10;
    width = 10;
  }
 
  //when a user want to check the number of kid from a specific room
  /*upcall [Building<nBuilding>::Room<nRoom>] deliver(const MaceKey& src, const MaceKey& dest, 
                                                    const CheckKidNum& msg) {
    downcall_route(src, KidNumReply(kidsInRoom.size()));
  }*/

  upcall deliver(const MaceKey& src, const MaceKey& dest, const RequireInitial& msg) {
    async_kidInitial(src);
  }

  upcall deliver(const MaceKey& src, const MaceKey& dest, const CheckKidNum& msg) {
    async_checkKidNum(msg.nBuilding, msg.nRoom, src);
  }
  
  upcall deliver(const MaceKey& src, const MaceKey& dest, const ChangeRoom& msg) {
    async_removeFromAisle(msg.originBuilding, msg.kidID);
    async_changeRoom(msg.nBuilding, msg.nRoom, msg.kidID);
  }

  upcall deliver(const MaceKey& src, const MaceKey& dest, const ChangeDirection& msg) {
    async_changeDirection(msg.kidID, msg.newDirection); 
  }

  async [Building<nBuilding>::Room<nRoom>] checkKidNum(uint16_t nBuilding, uint16_t nRoom, 
                                                      const MaceKey& src) {
    downcall_route(src, KidNumReply(kidsInRoom.size()));
  }
  
  async [Kid<nKid>] changeDirection(uint16_t kidID, uint16_t direction) {
    kidDirection = direction;
  }

  scheduler [Kid<nKid>] kidRun(uint16_t nKid) {
    int tmpX = x_coordinate, tmpY = y_coordinate;
    //it first reschedule the timer
    kidRun.reschedule(BREAKTIME, nKid);
    if (location == 0) {
      //then move the kid
      //the kid first attempt to move
      if(kidDirection == 1) {
        tmpY++;
      }
      else if (kidDirection == 2) {
        tmpY--;
      }
      else if (kidDirection == 3) {
        tmpX--;
      }
      else if (kidDirection == 4) {
        tmpX++;
      }
      else {
        //if the direction is set to 0 which means not move
        return;
      }
      //check if this attempt step is cross the boundary
      if (tmpX > xRoom || tmpY > yRoom) {
        //the kid won't move until the direction has been changed
        return;
      }
      else {
        //if the coordinate doesn't cross the boundary
        async_ifICanMove(nBuilding, nRoom, nKid, roleStatus, tmpX, tmpY);
      }
    }
    else {
      //if that kid is in aisle, then do nothing
    }
  }
 

  async [Building<nBuilding>::Room<nRoom>] ifICanMove(uint16_t nBuilding, uint16_t nRoom, 
                                                      uint16_t nKid, int role, uint16_t tmpX,
                                                      uint16_t tmpY) {
    bool ifLegal = false;
    //step 1:check matrix in this room
    if (kidsMap[tmpX][tmpY] < 0) {
      //the kid can move to this block
      ifLegal = true;
    }
    if (ifLegal == true)
    {
      kidsMap[tmpX][tmpY] = nKid;
      async_kidMove(nKid, tmpX, tmpY);
      //change room state, matrix
    }
    //if someone is tagged, switch the role and teleport "it" to aisle
    else if (ifLegal == false && role == 1) {
      //change the role status
      async_setToIt(kidsMap[tmpX][tmpY]);
      async_setToNormal(nKid);
      //remove "it" from the current room
      async_removeFromRoom(nBuilding, nRoom, kidsMap[tmpX][tmpY]);
      async_teleportToAisle(nBuilding, kidsMap[tmpX][tmpY]);
      kidsMap[tmpX][tmpY] = -1;
    }

  }
 
  async [Kid<nKid>] kidMove(uint16_t nKid, uint16_t tmpX, uint16_t tmpY) {
    //move the kid to the new position
    x_coordinate = tmpX;
    y_coordinate = tmpY;
  }


  async [Kid<nKid>] setToIt(uint16_t nKid) {
    roleStatus = 1;
  }

  async [Kid<nKid>] setToNormal(uint16_t nKid) {
    roleStatus = 0;

  }
  
  async [Building<nBuilding>::Room<nRoom>] removeFromRoom(uint16_t nBuilding, uint16_t nRoom,
                                                          uint16_t nKid) {
    kidsInRoom.erase(nKid);
  }

  async [Building<nBuilding>::Aisle] removeFromAisle(uint16_t nBuilding, uint16_t nKid) {
    kidsInAisle.erase(nKid); 
  }

  async [Building<nBuilding>::Room<nRoom>] changeRoom(uint16_t nBuilding, uint16_t nRoom, 
                                                      uint16_t nKid) {
    kidsInRoom.insert(nKid); 
    //insert the kid to one of the block that has not been occupied
    for (int i = 0; i < length; i++) {
      for (int j = 0; j < width; j++) {
        if (kidsMap[i][j] < 0) { 
          kidsMap[i][j] = nKid;
          async_updateKidStatus(nKid, nBuilding, nRoom, i, j); 
          goto label;
        }
      }
    }
    label:
  }
  //update date the status of a kid when his room has changed
  async [Kid<nKid>] updateKidStatus(uint16_t nKid, uint16_t nBuilding, uint16_t nRoom,
                                    uint16_t x, uint16_t y) {
    location = 1;
    currentBuilding = nBuilding;
    currentRoom = nRoom;
    x_coordinate = x;
    y_coordinate = y;
  }
  
  async [Building<nBuilding>::Aisle] teleportToAisle(nBuilding, nKid) {
    //change "it" to aisle
    kidsInAisle.insert(nKid); 
  }

}
