#include "marray.h"

service Tag;

trace=high;
 
services {
  //Transport t::9000 = auto(shared,[reliable,inorder],[]);
  Transport tcp::9000 = TcpTransport();
}
 
//1st thing need to be done, move the hardcoded parameters
//to prams.default
constants {
  //the maximum time that a child can stay in the same spot
  uint64_t MOVEMENT_PERIOD = 1000 * 1000;
  //the maximum size that a room can have
  uint16_t MAXIMUMSIZE = 20;
  //the kid direction constants
  uint16_t DIRECTION_STATIONARY = 0;
  uint16_t DIRECTION_UP = 1;
  uint16_t DIRECTION_DOWN = 2;
  uint16_t DIRECTION_LEFT = 3;
  uint16_t DIRECTION_RIGHT = 4;
  //the default room size constants
  uint16_t DEFAULT_ROOM_LENGTH = 10;
  uint16_t DEFAULT_ROOM_WIDTH = 10;
  //indicates the role of kid
  uint16_t KID_ROLE_NORMAL = 0;
  uint16_t KID_ROLE_IT = 1;
  //indicates the location that the kid stays in
  uint16_t LOCATION_IN_ROOM = 0;
  uint16_t LOCATION_IN_AISLE = 1;
  //indicates the default location that the kid stays
  uint16_t DEFAULT_BUILDING = 1;
  uint16_t DEFAULT_ROOM = 0;
  uint16_t DEFAULT_X_COOR = 0;
  uint16_t DEFAULT_Y_COOR = 0;
  //hard code the number for now
  uint16_t NBUILDING = 2;
  uint16_t NROOM = 2;
  uint16_t NKID = 2;
}
 
constructor_parameters {
  
}

states {
  //after all the contexts have been initialized, the state change to ready
  ready;
}
 
#minclude "TagMessage.mi"

state_variables {
  timer kidRun __attribute((recur(MOVEMENT_PERIOD)));
  context Building <uint16_t nBuilding> {
  	uint16_t buildingID;
    context Room <uint16_t nRoom> {
			uint16_t roomID;
			mace::set<uint16_t> kidsInRoom;
			uint16_t length;
			uint16_t width;
			mace::array<mace::array<int, MAXIMUMSIZE>, MAXIMUMSIZE> kidsMap;
    }
    //aisle is special place for transtions
    //"it" can't tag kids in aisle
    context Aisle {
			//a set keeps track of the ID of the kids
			mace::set<uint16_t> kidsInAisle;
    }
  }
  context Kid <uint16_t nKid> {
  	//indicates the ID of a kid
    uint16_t kidID;
		//indicate that if the kid is "it", '1' is "it"
    uint16_t roleStatus;
    //indicate if the kid is in the aisle or in the room
    //0 represent the "Room", 1 represent the "Aisle"
    int location;
    //indicates the location of the kids
    uint16_t currentBuilding;
    uint16_t currentRoom;
    uint16_t x_coordinate;
    uint16_t y_coordinate;
    //indicates the boudary of the room that the kid currently stayed
    uint16_t xBoundary;
    uint16_t yBoundary;
    //indicates the direction that a kid runs
    //'0' is not move, '1','2','3','4' means up, down, left, right
    uint16_t kidDirection;
  }
}

//2nd thing need to be done is rewrite the initialization part
transitions {
  downcall (state == init) maceInit() {
		//initial buildings and rooms
    maceout << "Initializing " << NBUILDING << " buildings and " << NROOM << " rooms." 
      << Log::endl;
    for (uint16_t bCount = 0; bCount < NBUILDING; bCount++) {
      async_buildingInit(bCount);
    }
    maceout << "Initializing " << NKID << " kids." << Log::endl; 
    for (uint16_t kCount = 0; kCount < NKID; kCount++) {
      async_kidInit(kCount);
    }
    /*kidRun.schedule(MOVEMENT_PERIOD);*/
    state = ready;
	}

  /*upcall  deliver(const MaceKey& src, const MaceKey& dest, const ChangeRoom& msg) {
    maceout << "ChangeRoom message has been received" << Log::endl;
    ASSERT(msg.kidID >= 1);
    if (returnKidLocation(msg.kidID) == LOCATION_IN_AISLE) {
      maceout << "Changeroom message has been received" << Log::endl;
      removeFromAisle(msg.srcBuilding, msg.kidID);
      if (changeToRoom(msg.destBuilding, msg.destRoom, msg.kidID)) {
        //downcall_route success
        downcall_route(src, ChangeRoomResult(msg.kidID, true));
      }
      else {
        //downcall_route fail
        downcall_route(src, ChangeRoomResult(msg.kidID, false));
      }
    }
    else {
      //suppose send back a invalid message
      maceout << "Kid No." << msg.kidID << " is not in aisle" << Log::endl;
      maceout << "Movement canceled" << Log::endl;
      downcall_route(src, ChangeRoomResult(msg.kidID, false));
    }
  }*/
  upcall [Kid<msg.kidID>] deliver(const MaceKey& src, const MaceKey& dest, const RequireKidInit& msg) {
    downcall_route(src, ResponseKidInit(kidID, roleStatus, location, currentBuilding, 
          currentRoom, x_coordinate, y_coordinate, xBoundary, yBoundary, kidDirection));
  }
  upcall [Kid<msg.kidID>] deliver(const MaceKey& src, const MaceKey& dest, const SetToIt& msg) {
    ASSERT(roleStatus != KID_ROLE_IT);
    roleStatus = KID_ROLE_IT;
    //setToIt(msg.kidID);
  }

  upcall [Building<msg.nBuilding>::Room<msg.nRoom>] deliver(const MaceKey& src, const MaceKey& dest, const RequireRoomInfo& msg) {
    /*maceout << "A RequireInfo message has been received" << Log::endl;
    returnRoomInfo(msg.nBuilding, msg.nRoom, src, msg.kidID);
    maceout << "A room information message has been send" << Log::endl;*/
    ASSERT(msg.kidID >= 1);
    downcall_route(src, ReceiveRoomInfo(msg.kidID, length, width, kidsMap)); 
  }
  
  upcall [Kid<msg.kidID>] deliver(const MaceKey& src, const MaceKey& dest, const SetDirection& msg) {
    /*maceout << "A SetDirection message has been received" << Log::endl;
    setKidDirection(msg.kidID, msg.newDirection);*/
    switch (msg.newDirection) {
      case DIRECTION_STATIONARY:
        kidDirection = msg.newDirection;
        break;
      case DIRECTION_UP:
        kidDirection = msg.newDirection;
        break;
      case DIRECTION_DOWN:
        kidDirection = msg.newDirection;
        break;
      case DIRECTION_LEFT:
        kidDirection = msg.newDirection;
        break;
      case DIRECTION_RIGHT:
        kidDirection = msg.newDirection;
        break;
      default:
        ABORT("Kid direction invalid!");
    }

  }

  async [Kid<nKid>] updateKidLocationAsync(uint16_t nKid, uint16_t newBuilding, uint16_t newRoom, uint16_t newX, uint16_t newY) {
    maceout << "Async call updateKidLocation has been called" << Log::endl;
    ASSERT(location == LOCATION_IN_AISLE || location == LOCATION_IN_ROOM);
    location  = LOCATION_IN_ROOM; 
    ASSERT(newBuilding >= 1);
    currentBuilding = newBuilding;
    ASSERT(newRoom >= 0);
    currentRoom = newRoom;
    
    x_coordinate = newX;
    y_coordinate = newY;
    kidDirection = DIRECTION_STATIONARY;
  }

  async [Kid<nKid>] setToItAsync(uint16_t nKid) {
    maceout << "Async call setToItAsync has been called" << Log::endl;
    ASSERT(roleStatus == KID_ROLE_NORMAL); 
    roleStatus = KID_ROLE_IT;
  }

  async [Kid<nKid>] setToNormalAsync(uint16_t nKid) {
    maceout << "Async call setToNormalAsync has been called" << Log::endl;
    ASSERT(roleStatus == KID_ROLE_IT); 
    roleStatus = KID_ROLE_NORMAL;
  }

  async teleportToAisleAsync(uint16_t nKid, uint16_t nBuilding, uint16_t nRoom, uint16_t x, uint16_t y) {
  //update the kid location first
    async_updateKidLocationAsync(nKid, nBuilding, DEFAULT_ROOM, DEFAULT_X_COOR, DEFAULT_Y_COOR);
    addToAisle(nBuilding, nKid);
    removeFromRoom(nBuilding, nRoom, nKid, x, y);
  }
  //initial a single building
  async [Building<nBuilding>] void buildingInit (int nBuilding) {
    maceout << "async call buildingInit has been called" << Log::endl;
    ASSERT(nBuilding >= 0);
    buildingID = nBuilding;  
    for (uint16_t rCount = 0; rCount < NROOM; rCount++) {
      async_roomInit(nBuilding, rCount);
    }
  }

  //initial a single room
  async [Building<nBuilding>::Room<nRoom>] void roomInit(int nBuilding, int nRoom) {
    maceout << "async call roomInit has been called" << Log::endl;
    ASSERT(nBuilding >= 0 && nRoom >= 0);
    roomID = nRoom;
    length = 10;
    width = 10;
  }

  //initial a single kid
  async [Kid<nKid>] void kidInit(int nKid) {
    maceout << "Async call kidInit has been called" << Log::endl;
    //initial all the attributes of the kid
    ASSERT(nKid >= 0);
    kidID = nKid;
    roleStatus = KID_ROLE_NORMAL;
    location = LOCATION_IN_AISLE;
    currentBuilding = DEFAULT_BUILDING;
    currentRoom = DEFAULT_ROOM;
    x_coordinate = DEFAULT_X_COOR;
    y_coordinate = DEFAULT_Y_COOR;
    xBoundary = DEFAULT_ROOM_LENGTH;
    yBoundary = DEFAULT_ROOM_WIDTH;
    kidDirection = DIRECTION_STATIONARY;
  }

  scheduler kidRun() {
    /*for (uint16_t i = 0; i < NKID; i++) {
      uint16_t oldX = getXCoor(i + 1);
      uint16_t oldY = getYCoor(i + 1);
      uint16_t newX = oldX;
      uint16_t newY = oldY;
      uint16_t nBuilding = getKidBuilding(i + 1);
      uint16_t nRoom = getKidRoom(i + 1);
      uint16_t kidDirection = getKidDirection(i + 1);
      uint16_t kidRole = getKidRole(i + 1);
      switch (kidDirection) {
        case DIRECTION_STATIONARY:
          return;
        case DIRECTION_UP:
          newY++;
          break;
        case DIRECTION_DOWN:
          newY--;
          break;
        case DIRECTION_LEFT:
          newX--;
          break;
        case DIRECTION_RIGHT:
          newX++;
          break;
        default:
          ABORT("Kid direction invalid!");
      }
      if (newX == 0 && newY == 0) {
        async_teleportToAisleAsync(i+1, nBuilding, nRoom, oldX, oldY);
      }
      else if(!ifBlockedByWall(i + 1, newX, newY))
        continue; 
      else if(!ifBlockedByKid(nBuilding, nRoom, oldX, oldY, newX, newY, i+1, kidRole)) {
        continue;
      }
    }*/
  }
}

routines {
  /*
  //initial a single building
  [Building<nBuilding>] void buildingInit (int nBuilding) {
    maceout << "Sync call buildingInit has been called" << Log::endl;
    ASSERT(nBuilding >= 1);
    buildingID = nBuilding;  
  }

  //initial a single room
  [Building<nBuilding>::Room<nRoom>] void roomInit(int nBuilding, int nRoom) {
    maceout << "Sync call roomInit has been called" << Log::endl;
    ASSERT(nBuilding >= 1 && nRoom >= 0);
    roomID = nRoom;
    length = 10;
    width = 10;
  }

  //initial a single kid
  [Kid<nKid>] void kidInit(int nKid) {
    maceout << "Sync call kidInit has been called" << Log::endl;
    //initial all the attributes of the kid
    ASSERT(nKid >= 1);
    kidID = nKid;
    roleStatus = KID_ROLE_NORMAL;
    location = LOCATION_IN_AISLE;
    currentBuilding = DEFAULT_BUILDING;
    currentRoom = DEFAULT_ROOM;
    x_coordinate = DEFAULT_X_COOR;
    y_coordinate = DEFAULT_Y_COOR;
    xBoundary = DEFAULT_ROOM_LENGTH;
    yBoundary = DEFAULT_ROOM_WIDTH;
    kidDirection = DIRECTION_STATIONARY;
  }*/

  //returns the kid location, whether in rooom or aisle
  [Kid<nKid>] int returnKidLocation(uint16_t nKid) {
    maceout << "Sync call returnKidLocation has been called" << Log::endl;
    ASSERT(location == LOCATION_IN_AISLE || location == LOCATION_IN_ROOM);
    return location; 
  }

  //remove the kid from the aisle
  [Building<nBuilding>::Aisle] bool removeFromAisle(uint16_t nBuilding, uint16_t kidID) {
    maceout << "Sync call removeFromAisle has been called" << Log::endl;
    //remove the kid from the kid container in aisle 
    ASSERT(kidsInAisle.containsKey(kidID));
    kidsInAisle.erase(kidID);
    return true;
  }

  [Building<nBuilding>::Room<nRoom>] bool removeFromRoom(uint16_t nBuilding, uint16_t nRoom, uint16_t kidID, uint16_t x, uint16_t y) {
    maceout << "Sync call removeFromRoom has been called" << Log::endl;
    ASSERT(kidsInRoom.containsKey(kidID));
    kidsInRoom.erase(kidID);
    kidsMap[x][y] = 0;
    return true;
  }

  [Building<nBuilding>::Aisle] bool addToAisle(uint16_t nBuilding, uint16_t nKid) {
    kidsInAisle.insert(nKid);
    return true;
  }

  //after remove the kid from the aisle, change the kid to the designated room
  [Building<nBuilding>::Room<nRoom>] bool changeToRoom(uint16_t nBuilding, uint16_t nRoom, uint16_t kidID) {
    maceout << "Sync call changeToRoom has been called" << Log::endl;
    //add the kid to the kid container in the room
    ASSERT(kidID >= 1);
    kidsInRoom.insert(kidID);
    //add the kid to the room map
    for (uint16_t i = 0; i < length; i++) {
      for (uint16_t j = 0; j < width; j++) {
        if (kidsMap[i][j] == 0 && ((i + j) != 0)) {
          //if there is a space in that room, then place the kid in the place
          async_updateKidLocationAsync(kidID, nBuilding, nRoom, i, j);
          kidsMap[i][j] = kidID;
          return true;
        }
      }
    }
    //if there is no space left in that room, then return false
    maceout << "There is no space left in Building No." << nBuilding << "Room No." << nRoom << Log::endl;
    return false;
  }

  [Kid<nKid>] bool ifBlockedByWall(uint16_t nKid, uint16_t tmpX, uint16_t tmpY) {
    maceout << "Sync call ifBlockedByWall has been called" << Log::endl;
    ASSERT(nKid >= 1);
    ASSERT(tmpX >= 0 && tmpY >= 0);
    //check if the kid can move
    if (tmpX >= xBoundary || tmpY >= yBoundary || tmpX < 0 || tmpY < 0) {
      maceout << "The kid No." << nKid << " has been blocked by the wall"<< Log::endl;
      return true;    
    }
    else
      return false;
  }

  [Building<nBuilding>::Room<nRoom>] bool ifBlockedByKid(uint16_t nBuilding, uint16_t nRoom, uint16_t oldX, uint16_t oldY, uint16_t newX, uint16_t newY, uint16_t nKid, uint16_t kidRole) {
    maceout << "Sync call ifBlockedByKid has been called" << Log::endl;
    if(kidsMap[newX][newY] == 0) {
      kidsMap[newX][newY] = nKid;
      kidsMap[oldX][oldY] = 0;
      return false;
    }
    else {
      if (kidRole == KID_ROLE_IT) {
        async_setToItAsync(kidsMap[newX][newY]);
        async_setToNormalAsync(nKid);
        //remove the new "it" from the map first
        async_teleportToAisleAsync(kidsMap[newX][newY], nBuilding, nRoom, newX, newY); 
        kidsMap[newX][newY] = 0;
      }
      maceout << "The kid No." << nKid << " has been blocked by the the kid No." << 
        kidsMap[newX][newY] << Log::endl;
      return true;
    }
  }

  [Kid<nKid>] uint16_t getKidDirection(uint16_t nKid) {
    maceout << "Sync call getKidDirection has been called" << Log::endl;
    ASSERT(nKid >= 1);
    return kidDirection;
  }

  [Kid<nKid>] uint16_t getKidBuilding(uint16_t nKid) {
    maceout << "Sync call getKidBuilding has been called" << Log::endl;
    ASSERT(nKid >= 1);
    return currentBuilding;
  }

  [Kid<nKid>] uint16_t getKidRoom(uint16_t nKid) {
    maceout << "Sync call getKidRoom has been called" << Log::endl;
    ASSERT(nKid >= 1);
    return currentRoom;
  }

  [Kid<nKid>] uint16_t getXCoor(uint16_t nKid) {
    maceout << "Sync call getXCoor has been called" << Log::endl;
    ASSERT(nKid >= 1);
    return x_coordinate;   
  }
  
  [Kid<nKid>] uint16_t getYCoor(uint16_t nKid) {
    maceout << "Sync call getYCoor has been called" << Log::endl;
    ASSERT(nKid >= 1);
    return y_coordinate; 
  }

  [Kid<nKid>] uint16_t getKidRole(uint16_t nKid) {
    maceout << "Sync call getKidRole has been called" << Log::endl;
    ASSERT(nKid >= 1);
    return roleStatus; 
  }

  [Building<nBuilding>::Room<nRoom>] void returnRoomInfo (uint16_t nBuilding, uint16_t nRoom, const MaceKey& src, uint16_t kidID) {
    maceout << "Sync call returnRoomInfo has been called" << Log::endl;
    ASSERT(kidID >= 1);
    downcall_route(src, ReceiveRoomInfo(kidID, length, width, kidsMap)); 
  }

  [Kid<nKid>] bool setToIt(uint16_t nKid) {
    maceout << "Sync call setToIt has been called" << Log::endl;
    ASSERT(roleStatus != KID_ROLE_IT);
    roleStatus = KID_ROLE_IT;
    return true;
  }

  [Kid<nKid>] bool setToNormal(uint16_t nKid) {
    maceout << "Sync call setToNormal has been called" << Log::endl;
    ASSERT(roleStatus != KID_ROLE_NORMAL);
    roleStatus = KID_ROLE_NORMAL;
    return true;
  }

  [Kid<nKid>] bool setKidDirection(uint16_t nKid, uint16_t newDirection) {
    maceout << "Sync call setKidDirection has been called" << Log::endl;
    switch (newDirection) {
      case DIRECTION_STATIONARY:
        kidDirection = newDirection;
        break;
      case DIRECTION_UP:
        kidDirection = newDirection;
        break;
      case DIRECTION_DOWN:
        kidDirection = newDirection;
        break;
      case DIRECTION_LEFT:
        kidDirection = newDirection;
        break;
      case DIRECTION_RIGHT:
        kidDirection = newDirection;
        break;
      default:
        ABORT("Kid direction invalid!");
    }
    return true;
  }
}
