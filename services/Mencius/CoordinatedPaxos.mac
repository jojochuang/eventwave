/* Pseudo code of Coordinated Paxos at server p. */
/* Each round of Coordinated Paxos is assigned to one of the servers(namely, coordinator). The round number is also called ballot number. */
/* Function owner(r) returns the server ID of the owner of round (ballot number) r. */
/* Note that this is only the pseudo code for one instance of Coordinated Paxos. */


/* PREPARE(b): PREPARE message for ballot number b */
/* ACK(b, ab, av): to acknowledge PREPARE(b):
	 ab is the highest ballot the sending server has accepted a value, 
	 and av is the value accepted for ballot ab. */
/* PROPOSE(b, v): to propose a value v with ballot number b. */
/* ACCEPT(b, v): to acknowledge PROPOSE(b, v) that the sending server has accepted v for ballot number b. */
/* LEARN(v): to inform other servers that value v has been chosen for this instance of simple consensus. */

service CoordinatedPaxos;

provides BasicConsensus;

trace = med;

services {
	Transport tcp = TcpTransport();
}

typedefs {
	typedef mace::deque<int>					IntList;
	typedef mace::deque<LearnerHistoryPair>		LearnerHistory;
	typedef mace::deque<PreparedHistoryPair>	PreparedHistory;
	typedef mace::map<int, Instance>			InstanceMap;
}


auto_types {
	LearnerHistoryPair {
		int ballot;
		mace::string value;
		MaceKey server;
	};

	PreparedHistoryPair {
		int ballot;
		int accepted_ballot;
		mace::string value;
		MaceKey server;
	};

	// Variables used at each instances:
	Instance {
		mace::string learned;
		bool is_learned;
		LearnerHistory learner_history;
		PreparedHistory prepared_history;
		int prepared_ballot;
		int accepted_ballot;
		mace::string accepted_value;
	};

}


messages {
	Propose {
		int instance;
		int ballot;
		mace::string value;
	};
	Skip {
		int instance;
		int ballot;
		// Value = no-op
	}
	Prepare {
		int instance;
		int ballot;
	};
	Learn {
		int instance;
		mace::string value;
	};
	Accept {
		int instance;
		int ballot;
		mace::string value;
	};
	Ack {
		int instance;
		int ballot;					// acknowledge Prepare(ballot)
		int accepted_ballot;		// highest ballot the sending server has accepted a value.
		mace::string accepted_value;	// value accepted for accepted_ballot.
	};

	Join {};
	NotReadyYet {};
}

states {
	joining;
	inited;
}


state_variables {
	InstanceMap instance_list;
	NodeSet servers;
	NodeSet joined;
	MaceKey me;

	registration_uid_t regId;
}


transitions {

	downcall void maceInit() {
		//me = upcall_getLocalAddress();
		//me = downcall_getLocalAddress();
		maceout << "Me = " << me << Log::endl;
	}

	downcall joinGroup(const NodeSet& group, registration_uid_t rid)		// Instances will be dynamically added.
	{
		servers = group;
		assert(servers.size() > 0);

		regId = rid;
		me = upcall_getLocalAddress(regId);

		joined = group;
		joined.erase(me);

		// Maybe we can use Bamboo...
		// IMPLEMENT-ME : While joining, periodically Join() message should be sent.

		maceout << "Sending Join()..." << Log::endl;

		for( NodeSet::iterator i = joined.begin(); i != joined.end(); i++ )
		{
			maceout << "Sending Join() to " << *i << Log::endl;
			downcall_route(*i, Join());
		}

		state = joining;

		if( joined.size() == 0)
		{
			state = inited;
			upcall_onReady(regId);
		}
	}

	upcall (state == init) deliver(src, dest, const Join& m)
	{
		maceout << "Sending NotReadyYet() to " << src << Log::endl;
		downcall_route(src, NotReadyYet());
	}

	upcall (state == joining) deliver(src, dest, const Join& m)
	{
		maceout << "Received Join() from " << src << Log::endl;
		joined.erase(src);
		if( joined.size() == 0)
		{
			state = inited;
			upcall_onReady(regId);
		}
	}

	upcall deliver(src, dest, const NotReadyYet& m)
	{
		maceout << "Sending Join() to " << src << Log::endl;
		downcall_route(src, Join());
	}


(state != init)
{

	downcall removeInstance(int instance, registration_uid_t rid)
	{
		assert( isRange(instance, instance_list) );
		removeInstance(instance);
	}


	downcall pushInstance(int instance, registration_uid_t rid)
	{
		assert( !isRange(instance, instance_list) );
		pushInstance(instance);
	}

	/* Coordinator can call either Suggest or Skip. */

	downcall suggest( int instance, const mace::string& v, registration_uid_t rid )		/* Coordinator proposes value v. */
	{
		//assert(isRange(instance, instance_list));		// instance ¡ô instance_list

		if( !isRange(instance, instance_list) )
			pushInstance(instance);

		broadcast( Propose(instance, 0, v) );
	}

	downcall skip( int instance, registration_uid_t rid )			/* Coordinator proposes no-op. */
	{
		//assert(isRange(instance, instance_list));		// instance ¡ô instance_list

		if( !isRange(instance, instance_list) )
			pushInstance(instance);

		broadcast( Skip(instance, 0) );
	}

	downcall revoke( int instance, registration_uid_t rid )		/* Non-coordinator starts to propose no-op. */
	{
		//assert(isRange(instance, instance_list));		// instance ¡ô instance_list

		if( !isRange(instance, instance_list) )
			pushInstance(instance);

		/* Choose a ballot number that is owned by p and greater than other ballot number p has ever seen. */
		/* ballot ¡ç Choose b : owner(b) = p && (b > prepared ballot) && (b > accepted ballot); */
		int ballot = upcall_getOwnedGreaterThanSelf((instance_list[instance].prepared_ballot > instance_list[instance].accepted_ballot) ? instance_list[instance].prepared_ballot : instance_list[instance].accepted_ballot, regId);

 		assert(ballot != -1);

		broadcast( Prepare(instance, ballot) ); /* Start phase 1 with a higher ballot number. */
	}

	downcall setLearnedSkip(int instance)
	{
		//assert(isRange(instance, instance_list));
		if( !isRange(instance, instance_list) )
			pushInstance(instance);

		// HOTFIX : If it already has learned value, skip it.

		if( instance_list[instance].is_learned == false )
		{
			instance_list[instance].is_learned = true;
			instance_list[instance].learned.clear();
		}
	}

	downcall setLearned(int instance, const mace::string& v)
	{
		//assert(isRange(instance, instance_list));
		if( !isRange(instance, instance_list) )
			pushInstance(instance);

		instance_list[instance].is_learned = true;
		instance_list[instance].learned = v;
	}

	downcall bool isLearned( int instance )
	{
		//assert(isRange(instance, instance_list));
		if( !isRange(instance, instance_list) )
			pushInstance(instance);

		return instance_list[instance].is_learned;
	}

	downcall const mace::string& getLearned( int instance )
	{
		assert(isRange(instance, instance_list));
		return instance_list[instance].learned;
	}

	upcall deliver(src, dest, const Prepare& m)
	{
		if( !isRange(m.instance, instance_list) )
			pushInstance(m.instance);

		propagateLearn(src, m);

		if( isRange(m.instance, instance_list) && !instance_list[m.instance].is_learned )
		{
			// If the received ballot is greater than we have, update it and send Ack with current accepted_ballot and accepted_value.
			if( m.ballot > instance_list[m.instance].prepared_ballot )
			{
				instance_list[m.instance].prepared_ballot = m.ballot;
				downcall_route( src, Ack(m.instance, m.ballot, instance_list[m.instance].accepted_ballot, instance_list[m.instance].accepted_value ) );
			}
		}
	}

	upcall deliver(src, dest, const Learn& m)
	{
		if( !isRange(m.instance, instance_list) )
			pushInstance(m.instance);

		if( isRange(m.instance, instance_list) /*&& !instance_list[m.instance].is_learned*/)
		{
			maceout << "Learned ("<<m.instance<<") = " << m.value << Log::endl;
			// Case 1: Not yet skipped.
			if( instance_list[m.instance].is_learned == false )
			{
				instance_list[m.instance].learned = m.value;
				instance_list[m.instance].is_learned = true;
				upcall_onLearned(m.instance, m.value, regId);
			}
			// Case 2: instance > expected (not committed) and Skipped
			else if( instance_list[m.instance].is_learned == true && upcall_isCommitted(m.instance, regId) == false)
			{
				instance_list[m.instance].learned = m.value;
				instance_list[m.instance].is_learned = true;
				upcall_onLearned(m.instance, m.value, regId);
			}
			// Case 3: instance < expected and probably skipped.
			else
			{
				upcall_onLearned(m.instance, m.value, regId);
			}

		}
	}

	upcall deliver(src, dest, const Accept& m)
	{
		if( !isRange(m.instance, instance_list) )
			pushInstance(m.instance);

		propagateLearn(src, m);

		if( isRange(m.instance, instance_list) && !instance_list[m.instance].is_learned )
		{
			if( m.ballot == 0 )
			{
				/* This ACCEPT message acknowledges a SUGGEST message. */
				upcall_onAcceptSuggestion (m.instance, src, regId); /* An upcall interface for Mencius. */
			}

			instance_list[m.instance].learner_history.push_back( LearnerHistoryPair( m.ballot, m.value, src) );

			// Count how many m.ballots do we have in learner_history
			LearnerHistory lset = instance_list[m.instance].learner_history;

			int count = 0;
			for (LearnerHistory::const_iterator i = lset.begin(); i != lset.end(); i++) {
				if( m.ballot == (*i).ballot )
					count++;
			}

			if( count == (int) ((servers.size() + 1)/2 + 0.5) )
			{
				/* a quorum has accepted the value, the value is chosen. */
				broadcast( Learn(m.instance, m.value) );
			}
		}
	}

	upcall deliver(src, dest, const Ack& m) /* Deal with instance */
	{

		if( !isRange(m.instance, instance_list) )
			pushInstance(m.instance);

		propagateLearn(src, m);

		if( isRange(m.instance, instance_list) && !instance_list[m.instance].is_learned )
		{

			instance_list[m.instance].prepared_history.push_back( PreparedHistoryPair( m.ballot, m.accepted_ballot, m.accepted_value, src) );

			PreparedHistory pset = instance_list[m.instance].prepared_history;

			int count = 0;
			for (PreparedHistory::const_iterator i = pset.begin(); i != pset.end(); i++) {
				if( m.ballot == (*i).ballot )
					count++;
			}

			if( count == (int) ((servers.size() + 1)/2 + 0.5) )
			{
				// Find the "highest" accepted ballot and its value

				int ha = -1;
				mace::string hv;
				for (PreparedHistory::const_iterator i = pset.begin(); i != pset.end(); i++) {
					if( (*i).accepted_ballot > ha )
					{
						ha = (*i).accepted_ballot;
						hv = (*i).value;
					}
				}

				// CHECKME
				if( ha == -1 || hv.empty() )
				{
					/* No value has been chosen yet, propose no-op. */
					broadcast( Skip(m.instance, m.ballot) );
				}
				else
				{
					/* Must propose hv. */
					broadcast( Propose(m.instance, m.ballot, hv) );
				}
			}
		}
	}

	upcall deliver(src, dest, const Propose& m) /* Deal with instance */
	{

		if( !isRange(m.instance, instance_list) )
			pushInstance(m.instance);

		propagateLearn(src, m);

		if( isRange(m.instance, instance_list) && !instance_list[m.instance].is_learned )
		{
			if (instance_list[m.instance].prepared_ballot <= m.ballot && instance_list[m.instance].accepted_ballot < m.ballot)
			{
				/* p accepts (b, v). */
				if (m.ballot == 0)
				{
					/* this is a SUGGEST message. */
					upcall_onSuggestion(m.instance, regId); /* An upcall interface for protocol P and Mencius. */
				}
				instance_list[m.instance].accepted_ballot = m.ballot;
				instance_list[m.instance].accepted_value = m.value;
				downcall_route( src, Accept(m.instance, m.ballot, m.value) );
			}
		}
	}

	upcall deliver(src, dest, const Skip& m) /* Deal with instance */
	{

		if( !isRange(m.instance, instance_list) )
			pushInstance(m.instance);

		propagateLearn(src, m);

		if( isRange(m.instance, instance_list) && !instance_list[m.instance].is_learned )
		{
			if (m.ballot == 0)
			{
				/* Coordinator skips, p learns no-op immediately */
				instance_list[m.instance].is_learned = true;
				instance_list[m.instance].learned.clear();
				upcall_onLearned(m.instance, instance_list[m.instance].learned, regId);
			}
			else if (instance_list[m.instance].prepared_ballot <= m.ballot && instance_list[m.instance].accepted_ballot < m.ballot)
			{
				/* p accepts (b, v). */
				if (m.ballot == 0)
				{
					/* this is a SUGGEST message. */
					upcall_onSuggestion(m.instance, regId); /* An upcall interface for protocol P and Mencius. */
				}
				instance_list[m.instance].accepted_ballot = m.ballot;
				instance_list[m.instance].accepted_value.clear();		// No-op
				downcall_route( src, Accept(m.instance, m.ballot, "") );
			}

		}
	}

	upcall error(const MaceKey& q, TransportError::type error_code, const std::string& m, registration_uid_t registrationUid) {
		maceerr << "Error from " << q << Log::endl;
		upcall_onSuspect(q, regId);
	}
}

}


routines{
	void broadcast( const Propose& m )
	{
		for (NodeSet::const_iterator i = servers.begin(); i != servers.end(); i++) {
			if( *i != me )
				downcall_route(*i, m);
		}
	}

	void broadcast( const Skip& m )
	{
		for (NodeSet::const_iterator i = servers.begin(); i != servers.end(); i++) {
			if( *i != me )
				downcall_route(*i, m);
		}
	}

	void broadcast( const Prepare& m )
	{
		for (NodeSet::const_iterator i = servers.begin(); i != servers.end(); i++) {
			if( *i != me )
				downcall_route(*i, m);
		}
	}


	void broadcast( const Learn& m )
	{
		for (NodeSet::const_iterator i = servers.begin(); i != servers.end(); i++) {
			//if( *i != me )
			downcall_route(*i, m);
		}
	}

	void broadcast( const Accept& m )
	{
		for (NodeSet::const_iterator i = servers.begin(); i != servers.end(); i++) {
			if( *i != me )
				downcall_route(*i, m);
		}
	}


	void propagateLearn( MaceKey src, const Propose& m )
	{
		assert(isRange(m.instance, instance_list));		// instance ¡ô instance_list

		if( instance_list[m.instance].is_learned )
		{
			downcall_route( src, Learn(m.instance, instance_list[m.instance].learned) );
		}
	}

	void propagateLearn( MaceKey src, const Skip& m ) 
	{
		assert(isRange(m.instance, instance_list));		// instance ¡ô instance_list

		if( instance_list[m.instance].is_learned )
		{
			downcall_route( src, Learn(m.instance, instance_list[m.instance].learned) );
		}
	}
	
	void propagateLearn( MaceKey src, const Prepare& m ) 
	{
		assert(isRange(m.instance, instance_list));		// instance ¡ô instance_list

		if( instance_list[m.instance].is_learned )
		{
			downcall_route( src, Learn(m.instance, instance_list[m.instance].learned) );
		}
	}
	
	//void propagateLearn( const Learn& m ) {}
	
	void propagateLearn( MaceKey src, const Accept& m ) 
	{
		assert(isRange(m.instance, instance_list));		// instance ¡ô instance_list

		if( instance_list[m.instance].is_learned )
		{
			downcall_route( src, Learn(m.instance, instance_list[m.instance].learned) );
		}
	}


	void propagateLearn( MaceKey src, const Ack& m ) 
	{
		assert(isRange(m.instance, instance_list));		// instance ¡ô instance_list

		if( instance_list[m.instance].is_learned )
		{
			downcall_route( src, Learn(m.instance, instance_list[m.instance].learned) );
		}
	}


	bool isRange( int instance, InstanceMap instance_list )
	{
		mace::map<int, Instance>::iterator it = instance_list.find(instance);

		return ( it != instance_list.end() );
	}

	void removeInstance(int instance)
	{
		if( isRange(instance, instance_list) )
		{
			instance_list.erase(instance);
		}
	}

	void pushInstance(int instance)
	{
		if( !isRange(instance, instance_list) )
		{
			Instance ins;
			ins.is_learned = false;
			ins.prepared_ballot = 0;
			ins.accepted_ballot = -1;

			instance_list.insert (mace::pair<int,Instance>(instance,ins) );
		}
	}
}
