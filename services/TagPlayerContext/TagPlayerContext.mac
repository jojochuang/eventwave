#include "marray.h"
#include "RandomUtil.h"
#include "mvector.h"
#include "mlist.h"
#include "m_map.h"
#include <stdio.h>
#include <sys/time.h>

service TagPlayerContext;
 
provides TagPlayer;
 
services {
  //Transport t::9000 = auto(shared,[],[]);
  Transport t::9000 = TcpTransport();
}
 
constants {
  //The maximun size that the room can have
  uint16_t MAXIMUM_SIZE = 20;
  uint16_t BUILDING_NUM = 2;
  uint16_t ROOM_NUM = 2;
}
 
constructor_parameters {
  //MaceKey serverAddr;
}

states {
  playing;
}
 
#minclude "MaceTagMessage.mi"

/*auto_types {
  player __attribute((comparable(equals = default; lessthan=default))){
    
    uint16_t playerID;
    uint16_t role;
    uint16_t nBuilding;
    uint16_t nRoom;
    uint16_t originalBuilding;
    uint16_t x_coordinate;
    uint16_t y_coordinate;
    uint16_t curDirection;
    uint16_t location;
    uint16_t length;
    uint16_t width;
    mace::array<mace::array<int, MAXIMUM_SIZE>,MAXIMUM_SIZE> roomMap;

  }
}*/

state_variables {
  /*MaceKey headAddr;
  uint64_t counter=0;
  //mace::map<uint16_t,player> Kids;
  //mace::vector<MaceKey> peerAddr;
  uint16_t KidplayerID;
  uint16_t Kidrole;
  uint16_t KidnBuilding;
  uint16_t KidnRoom;
  uint16_t KidoriginalBuilding;
  uint16_t Kidx_coordinate;
  uint16_t Kidy_coordinate;
  uint16_t KidcurDirection;
  uint16_t Kidlocation;
  uint16_t Kidlength;
  uint16_t Kidwidth;
  mace::array<mace::array<int, MAXIMUM_SIZE>,MAXIMUM_SIZE> roomMap;
  //MaceKey 
  
  //uint32_t 
  //timeval tim2;
  double t1;
  double t2;*/
  MaceKey serverAddr; 
  uint16_t playerID;
  uint16_t playerRole;
  int playerLocation;
  uint16_t playerBuilding;
  uint16_t playerRoom;
  uint16_t playerCoorX;
  uint16_t playerCoorY;
  uint16_t roomBoundaryX;
  uint16_t roomBoundaryY;
  uint16_t playerDirection;

}
 
transitions {
 
  downcall (state==init) maceInit()
  {
    /* 
    maceout<<localAddress()<<Log::endl;
    //for(i=1;i<=50;i++)
    { 
    player peer;
    peer.playerID = i;
    peer.role = 0;
    peer.location = 1;
    peer.originalBuilding = 0;
    peer.curDirection = i%5;
    Kids.insert(pair<uint16_t,player>(i,peer));
    //KidplayerID = 1;
    Kidrole = 0;
    Kidlocation = 1;
    KidoriginalBuilding = 2;
    KidnBuilding = 1 ;
    KidcurDirection = 5;
    //printInfo(Kids[i]);
    //if(i==1)
    //{
    //}
    //downcall_route(headAddr,RequireInitial(i));
      //downcall_route(headAddr,ChangeDirection(Kids[i].curDirection,i));
    //}
    
    //join the game and get the PlayerID
    
    //downcall_movePlayer(curDirection);
    //downcall_route(headAddr,RequireInitial());
    //maceout<<"Send initial to server"<<Log::endl;*/
    maceout << "Player Init has been called." << Log::endl; 
    serverAddr = MaceKey(ipv4, params::get<std::string>("SERVER_ADDR") );
    //downcall_route(serverAddr, RequireKidInit(0));
    for (int i = 0; i < 3; i++) {
      downcall_route(serverAddr, ChangeRoom(i, 0, 0, 0));
    }
  }

  upcall deliver(const MaceKey& src, const MaceKey& dest, const ResponseKidInit& msg) {
    maceout << "A ResponseKidInit msg has been received." << Log::endl;
    playerID = msg.kidID;
    playerRole = msg.kidRole;
    playerLocation = msg.kidLocation;
    playerBuilding = msg.kidBuilding;
    playerRoom = msg.kidRoom;
    playerCoorX = msg.kidCoorX;
    playerCoorY = msg.kidCoorY;
    roomBoundaryX = msg.roomBoundaryX;
    roomBoundaryY = msg.roomBoundaryY;
    playerDirection = msg.playerDirection;
    maceout << "A Kid has been initialized." << Log::endl;
  }

  /*//recevie ID from server
  upcall deliver(const MaceKey& src, const MaceKey& dest, const ReceiveInitial& msg)
  {
    int i;
    i=msg.kidID;
   
    Kids[i].role = msg.role;
   
    settheRoom(i,RandomUtil::randInt(BUILDING_NUM),RandomUtil::randInt(ROOM_NUM));
  }*/
 
 
  //Require Room Map
  /*downcall requireRoomMap(uint16_t id,uint16_t nBuilding,uint16_t nRoom)
  {
    timeval tim;
    maceout << id <<" start require room map"<< Log::endl;
    gettimeofday(&tim, NULL);
    t1 = tim.tv_sec + (tim.tv_usec / 1000000.0);
    //maceout << id << ", " <<  nBuilding << ", " << nRoom << Log::endl;
    KidplayerID = id;
    //if(Kidlocation == 0)
      downcall_route(headAddr,RequireRoomInfo(KidplayerID,KidnBuilding, KidnRoom));
  }*/
 
  //move player
  /*downcall movePlayer(uint16_t id,uint16_t direction) {
     timeval tim;
     gettimeofday(&tim, NULL);
    t1 = tim.tv_sec + (tim.tv_usec / 1000000.0);
    maceout<<"Strat Sending"<<Log::endl;
    KidplayerID = id;
    KidcurDirection = direction;
    downcall_route(headAddr,SetDirection(id,KidcurDirection));
  }*/
 
  //user decides to change to other room
  /*downcall changeRoom(uint16_t id,uint16_t newBuilding, uint16_t newRoom)
  {
    timeval tim;
     gettimeofday(&tim, NULL);
    t1 = tim.tv_sec + (tim.tv_usec / 1000000.0);
    //maceout << id << Log::endl;
    KidplayerID = id;
    KidoriginalBuilding = KidnBuilding;
    KidnBuilding = newBuilding;
    KidnRoom = newRoom;
    
    
    //maceout << KidoriginalBuilding << ", " << KidoriginalBuilding << ", "<< newRoom << Log::endl;
    
    downcall_route(headAddr,ChangeRoom(id, KidoriginalBuilding ,KidoriginalBuilding,newRoom));
    maceout << id << "send change room!"<< Log::endl;
    
  }*/
//}
 
  //check how many kids in certain room
  /*downcall checkKidNum(uint16_t id,uint16_t nBuilding, uint16_t nRoom)
  {
    downcall_route(headAddr,CheckKidNum(id,nBuilding, nRoom));
  }*/
 
  //send the message to other player
  /*downcall sendmsg(uint16_t id)
  {
    KidplayerID = id;
    maceout<<id<<" Send SET TO IT!!"<<Log::endl;
    //MaceKey dest = peerAddr[id];
    //downcall_route(dest,ChatMsg("Hello"));
    //if(KidplayerID ==1)
       downcall_route(headAddr, SetToIt(KidplayerID));
  }*/
 
 
  /*upcall deliver(const MaceKey& src, const MaceKey& dest, const ChangeRoomResult& msg)
  {
    if(msg.kidID == KidplayerID)
    {
      if(msg.result == true)
      {
        maceout<<"Change room success!!"<<Log::endl;
        Kidlocation=0;
      }
      else
        maceout<<"Change room fail!!"<<Log::endl;
    }
    else
      maceout<<"Not my business"<<Log::endl;
  }*/ 
 
 
  //receive the room information that I am there
 /* upcall deliver(const MaceKey& src, const MaceKey& dest, const ReceivePosition& msg)
  {
    uint16_t i;
    i = msg.kidID;
    //role = msg.role;  
    Kids[i].location = 0;
    Kids[i].x_coordinate = msg.x_coordinate;
    Kids[i].y_coordinate = msg.y_coordinate;
    //downcall_requireRoomMap(nBuilding, nRoom);
    Kids[i].nBuilding = msg.nBuilding;
    Kids[i].nRoom = msg.nRoom;
    downcall_route(headAddr,RequireRoomInfo(i,Kids[i].nBuilding, Kids[i].nRoom));
  }*/
 
  //receive new position after every movement
  /*upcall (state==playing) deliver(const MaceKey& src, const MaceKey& dest, const ReceivePosition& msg)
  {
    uint16_t i;
    i = msg.nKid;
    //role = msg.role;  
    Kids[i].location = 0;
    Kids[i].x_coordinate = msg.x_coordinate;
    Kids[i].y_coordinate = msg.y_coordinate;
    //downcall_requireRoomMap(nBuilding, nRoom);
    Kids[i].nBuilding = msg.nBuilding;
    Kids[i].nRoom = msg.nRoom;
    printInfo(Kids[i]);
  }*/
  
  //Test SetDirection() command
 
  //Receive the room Map
  /*upcall deliver(const MaceKey& src, const MaceKey& dest, const ReceiveRoomInfo& msg)
  {
    int i,j;
    uint16_t id;
    timeval tim2;
    counter++;
    maceout << "Receive" << counter<<" room map"<<Log::endl;
     if(counter<=1000)
     {
       //downcall_route(headAddr,RequireRoomInfo(1,1));
       
     }
     if(counter==1000)
     {
        gettimeofday(&tim2, NULL);
       t2 = tim2.tv_sec + (tim2.tv_usec / 1000000.0);
       //printf("%.6lf seconds elapsed\n", t2 - t1);
     }
    
    id = msg.kidID;
    Kidlength = msg.length;
    Kidwidth = msg.width;
    for(i=0;i<Kidlength;i++)
    {
      for(j=0;j<Kidwidth;j++)
      {
        roomMap[i][j]= msg.map[i][j];
        maceout << roomMap[i][j];
      }
      maceout<<Log::endl;
    }
    //state=playing;
  }*/
 
  //receive the message that I am it and send the command to go to a new room
 /* upcall deliver(const MaceKey& src, const MaceKey& dest, const IamIT& msg)
  {
    uint16_t id;
    id = msg.kidID;
   
    if(msg.role==1)
    {
      Kids[id].x_coordinate = msg.x_coordinate;
      Kids[id].y_coordinate = msg.y_coordinate;
      Kids[id].role = msg.role;
      Kids[id].location = msg.location;
    }
   
    settheRoom(id,RandomUtil::randInt(BUILDING_NUM),RandomUtil::randInt(ROOM_NUM));
  }
 
 
 
  upcall deliver(const MaceKey& src, const MaceKey& dest, const KidNumReply& msg)
  {
    upcall_printkidNum(msg.kidNum);
  }
 
 
  //reveice and print the message
  upcall deliver(const MaceKey& src, const MaceKey& dest, const ChatMsg& msg)
  {
    upcall_printmsg(msg.message);
  }
}*/
  /*downcall sendmsg(uint16_t id)
  {
    MaceKey dest = peerAddr[id];
    downcall_route(dest,ChatMsg("Hello"));
  }
  
  upcall deliver(const MaceKey& src, const MaceKey& dest, const ChatMsg& msg)
  {
    upcall_printmsg(msg.message);
  }*/
}

routines {
  /*void MovePlayer(uint16_t id,uint16_t direction) {
     //maceout<<"Still Sending"<<Log::endl;
    KidcurDirection = direction;
    downcall_route(headAddr,SetDirection(id,KidcurDirection));
  }
  void Changeroom(uint16_t id,uint16_t newBuilding, uint16_t newRoom)
  {
    maceout << id << Log::endl;
    KidoriginalBuilding = 2;
    KidnBuilding = newBuilding;
    KidnRoom = newRoom;
    
    maceout << KidoriginalBuilding << ", " <<  newBuilding << ", " << newRoom << Log::endl;

    downcall_route(headAddr,ChangeRoom(id, KidoriginalBuilding ,newBuilding,newRoom));

    
  }*/
}
