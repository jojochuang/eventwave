 #include "boost/format.hpp"
 #include <sstream>
 #include <math.h>
service Simple;
trace=high;
//provides ServComp;
typedefs {
    typedef mace::vector< mace::vector<double> > Matrix;
}
services {
    Transport tcp = TcpTransport();
}
 
states{
}

constants {
    int32_t DEFAULT_ROWS    =   5;
    int32_t DEFAULT_COLUMNS =   5;
    uint64_t HEARTBEAT_PERIOD = 500*1000; // Period between each resend every 0.5 second
}
/**
chuangw:
to change default parameter values to foo, in parameters.default, set
ServiceConfig.LUFactorization.ROWS = foo and
ServiceConfig.LUFactorization.COLUMNS = foo
*/
constructor_parameters {
    int32_t ROWS = DEFAULT_ROWS;
    int32_t COLUMNS = DEFAULT_COLUMNS;

    int32_t MATRIXROWS = DEFAULT_ROWS;
    int32_t MATRIXCOLUMNS = DEFAULT_COLUMNS;
}
 
state_variables {
  timer<MaceKey> ctsTimer __attribute((multi(yes)));
   Matrix initial_matrix;
   int rows;
   int columns;

   int matrix_rows;
   int matrix_columns;

   int current_iteration;
   int init_rows;
   int finished_row;
   int returnedValues;
   Matrix result;

   context R<int ROWS>{ 
       int init_cells;
      int finished_cell;
      context C<int COLUMNS>{
         //double value;
         int matrix_row_from;
         int matrix_column_from;
         Matrix values;

         bool receivedPivotRow;
         bool receivedPivotColumn;

         context X<int TEST>{
            bool testX;
            timer context_test_timer  __attribute((multi(yes)));
         }
      }
   }
   context T{
     bool test;
   }
   context M<uint32_t m1, mace::string str>{
    bool test;    
   }
   int runs;
   //timer resend_timer __attribute((recur(HEARTBEAT_PERIOD)));
}
// implicitly declare x,y as state variable of the context

/*contexts {
    R<int ROWS>{ 
        int init_cells;
        int finished_cell;
    }
    C<int COLUMNS>{
        //double value;
        int matrix_row_from;
        int matrix_column_from;
        Matrix values;
        mace::vector<double> topVals;
        mace::vector<double> leftVals;

        bool receivedPivotRow;
        bool receivedPivotColumn;
    }
    R[i]C[j] (0<=i<=10;0<=j<=10 )
}*/
 
transitions {

   downcall (state == init)maceInit()  {
       /*bool a = sync_sctest();
       a = false;*/
       rows = ROWS;
       columns = COLUMNS;

       matrix_rows = MATRIXROWS;
       matrix_columns = MATRIXCOLUMNS;

       initial_matrix.resize( rows );
       result.resize( rows );
       current_iteration = 0;
       finished_row = 0;
       init_rows = 0;
       runs = 0;
       for(int i=0;i< rows;i++){
           initial_matrix[i].resize( columns );
           result[i].resize( columns );
       }

       for( int i=0;i< rows; i++ ){
           async_rowInit( i,0 );
       }
   }
   sync [T](state==init) bool sctest(){
        return true;
   }

   //async [R<row>, R<x> as Rx](state==init)rowInit( int row,int x ){
   async [R<row>](state==init)rowInit( int row,int x ){
   // bug: what if snapshot context is the same as the target context??
      finished_cell  = 0;
      init_cells  = 0;

      for( int j=0;j<columns;j++){
         bool a = sync_cellInit(row,j);
         a = false;
      }
   }
   //sync [R<row>::C<column>, R<row> as myRow, T as TContext](state==init) bool cellInit( int row, int column){
   sync [R<row>::C<column>](state==init) bool cellInit( int row, int column){

      // locally generates values
      values.resize( ( matrix_rows/rows) );
      for(int i=0;i< ( matrix_rows/rows); i++ ){
         values[i].resize( ( matrix_columns/columns) );
         for(int j=0;j< ( matrix_rows/rows); j++ ){
            values[i][j] = RandomUtil::randInt(1000);
         }
      }
//      int row_init_cells = Row.init_cells;

      matrix_row_from    = row * ( matrix_rows / rows );
      matrix_column_from = column * ( matrix_columns / rows );

      receivedPivotRow = false;
      receivedPivotColumn = false;

      async_rowAfter(row);

      //sync_testRCX(row,column,1);

      return true;
   }

   async [R<row>] rowAfter(int row){
        //int rows_snapshot = rows;
   }
   sync [R<row>::C<column>::X<x>, R<row>::C<column> as myCell, R<row> as myRow, T as TContext](state==init) void testRCX( int row, int column, int x){
   }
   /*downcall [R<n>] uint32_t test(uint32_t n){
    return 1;
   }*/
   scheduler [R<row>::C<column>::X<x>] context_test_timer(int& row, int& column, int& x){
        
   }
  scheduler ctsTimer(MaceKey& dest) {
  }
  async [M<m1,str>] testMulti( uint32_t m1, mace::string str){
    
  }
}
