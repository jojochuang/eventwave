/* 
 * GameOfLifeStencil.mac : part of the Mace toolkit for building distributed systems
 * 
 * Copyright (c) 2012, Bo Sang
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the names of the contributors, nor their associated universities 
 *      or organizations may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * ----END-OF-LEGAL-STUFF---- 
*/

#include "mlist.h"
#include "marray.h"
#include "mdeque.h"
#incldeu "mmap.h"

#include <sys/time.h>
#include <time.h>

service NPB_MGApplication;
provides MG;

trace = med;

constants {
	int lm = 8;
	int lt = 8;
	int lb = 1;
  int m = 11;

	int NXYZ_DEFAULT = 256;
  int lt_default = 8;
  int nit_default = 20;

  int Z_FLAG = 0;    
	int U_FLAG = 1;
	int R_FLAG = 2;

  mg3P_loop01_rprj3 = 3;
  mg3P_psinv01 = 4;
  mg3P_loop02_interp01 = 5;
  mg3P_loop02_resid01 = 6;
  mg3P_loop02_psinv01 = 7;
  mg3P_interp01 = 8;
  mg3P_resid01 = 9;
  mg3P_psinv02 = 10;
  execute_resid01 = 11;
  execute_resid02 = 12;
  execute_resid03 = 13;
  execute_loop01_resid01 = 14;
  execute_mg3P01 = 15;
  execute_loop01_mg3P01 = 16;
	execute_zran0301 = 17;
	execute_zran0302 = 18;

	int CONTEXTS_NUM = 4;
}

services {
    GenericStencil stencil = GenericStencil();
}

states {

}

method_remappings {
	uses {
		downcall_update_values( mace::deque<Position>& idxes->mace::deque<std::string>& idxes, mace::deque<uint64_t>& rounds, 
			mace::deque<double>& vals->mace::deque<std::string>& vals, int flag);

		downcall_add_barrier( mace::deque<Position>& required_vars->mace::deque<std::string>& required_vars, mace::deque<int>& flags, 
			mace::deque<double>& vars->mace::deque<std::string>& vars, Identifier& identifier->std::string identifier);

		upcall_val_updated( mace::deque<std::string>& required_vars->mace::deque<Postion>& required_vars, 
			mace::deque<std:string>& vals->mace::deque<double>& vals, mace::deque<std::string>& vars->mace::deque<double>& vars, 
			std::string& identifier->Identifier& identifier);
	}	
}

constructor_parameters {
    
}

auto_types {
    Position __attribute((comparable(equals=default; lessthan=default))){
        int x;
        int y;
				int z;
    }

	Scale {
		int Xmin;
		int Xmax;
		int Ymin;
		int Ymax;
		int Zmin;
		int Zmax;
	}


	Identifier {
  	Position pos;
    int id;
	}
}

typedefs {
  		
}

state_variables {
		char class_type;

		context Element<int, int, int> {
			Position pos;
			Scale scl;

      double u[NXYZ_DEFAULT+2][NXYZ_DEFAULT+2][NXYZ_DEFAULT+2];
      double r[NXYZ_DEFAULT+2][NXYZ_DEFAULT+2][NXYZ_DEFAULT+2];
      double v[NXYZ_DEFAULT+2][NXYZ_DEFAULT+2][NXYZ_DEFAULT+2];

      int cur_state;
      int mg3P_state;
      uint64_t round;

      int nit;
      int nx[m], ny[m], nz[m], m1[m], m2[m], m3[m];
      int ir[3][m];
      int is1, is2, is3, ie1, ie2, ie3;
      int n1, n2, n3;
      double a[4], c[4];

      mace::stack<int> loop_indicator;
		}
}

messages {
				
}

transitions {
	downcall maceInit(){
		int x_split, y_split, z_split;
		x_split = y_split = z_split = NXYZ_DEFAULT/CONTEXTS_NUM;
		
		int xi, yi, zi;
		int curX, curY, curZ;
		
		curX = 1;
		for(xi=0; xi<CONTEXTS_NUM; xi++){
			curY = 1;
			for(yi=0; yi<CONTEXTS_NUM; yi++){
				curZ = 1;
				for(zi=0; zi<CONTEXTS_NUM; zi++){
					Scale scl;
					scl.Xmin = curX;
					scl.Ymin = curY;
					scl.Zmin = curZ;
					if(zi == CONTEXTS_NUM-1){
						scl.Zmax = NXYZ_DEFAULT;
					}else{
						scl.Zmax = curZ+z_split-1;
					}

					if(yi == CONTEXTS_NUM-1){
						scl.Ymax = NXYZ_DEFAULT;	
					}else{
						scl.Ymax = curY+y_split-1;	
					}

					if(xi == CONTEXTS_NUM-1){
						scl.Xmax = NXYZ_DEFAULT;	
					}esle{
						scl.Xmax = curX+x_split-1;	
					}
					curZ += z_split;
					async_context_init(xi, yi, zi, scl);
				}
				curY += y_split;
			}
			curX += x_split;
		}
	}

  upcall [__null] val_updated( mace::deque<Position>& required_vars, mace::deque<double>& required_vals, 
			mace::deque<double>& vars,  Identifier& identifier){
  	Position pos = identifier.pos;

		mace::map<Position, double> vals_map;
		int i;
		for(i=0; i<required_vars.size(); i++){
			vals_map[required_vars[i]] = required_vals[i];	
		}
		async_val_updated(pos.x, pos.y, pos.z, vals_map, vars);
	}

    async context_init [Element<x, y, z>] (uint64_t x, uint64_t y, uint64_t z, Scale init_scl){
    	round = 0;
			scl = scl;
			pos.x = x;
			pos.y = y;
			pos.z = z;
			
			a[0] = -8/3;
    	a[1] = 0;
    	a[2] = 1/6;
    	a[3] = 1/12;

    	c[0] = -3/8;
    	c[1] = 1/32;
    	c[2] = -1/64;
    	c[3] = 0;

    	lt = lt_default;
    	nit = nit_default;

    	int k, d, i, j;
    	int ax;
    	int size1=3, size2=10;
    	//setup to intialize variables
    	nx[lt-1] = NXYZ_DEFAULT;
    	ny[lt-1] = NXYZ_DEFAULT;
    	nz[lt-1] = NXYZ_DEFAULT;
        
    	ng[0][lt-1] = nx[lt-1];
    	ng[1][lt-1] = ny[lt-1];
    	ng[2][lt-1] = nz[lt-1];
         
    	for(ax=0; ax<size1; ax++){
    		for(k=lt-2; k>=0; k--){
      		ng[ax][k] = ng[ax][k+1]/2;  
      	}
    	}
        
    	for(k=lt-2; k>=0; k--){
    		nx[k] = ng[0][k];
      	ny[k] = ng[1][k];
      	nz[k] = ng[2][k];
    	}
         
    	for(k=lt-1; k>=0; k--){
    		for(ax=0; ax<3; ax++){
      		mi[ax][k] = 2 + ng[ax][k];  
      	}
      	m1[k] = mi[0][k];
      	m2[k] = mi[1][k];
      	m3[k] = mi[2][k];
    	}
         
    	k = lt-1;
    	is1 = 2 + ng[0][k] - ng[0][k];
    	ie1 = 1 + ng[0][k];
    	n1 = 3 + ie1 - is1;
    	is2 = 2 + ng[1][k] - ng[1][k];
    	ie2 = 1 + ng[1][k];
    	n2 = 3 + ie2 - is2;
    	is3 = 2 + ng[2][k] - ng[2][k];
    	ie3 = 1 + ng[2][k];
    	n3 = 3 + ie3 - is3;
        
    	ir[0][lt-1] = 0;
    	ir[1][lt-1] = 0;
    	ir[2][lt-1] = 0;
    	for(j=lt-2; j>=0; j--){
    		ir[0][j] = ir[0][j+1] + m1[j+1]/2;
      	ir[1][j] = ir[1][j+1] + m2[j+1]/2;
      	ir[2][j] = ir[2][j+1] + m3[j+1]/2;
    	}
        
			zero3(u, 0, 0, 0, n1, n2, n3);

			if(x==0 && y==0 && z==0 ){
				cur_state = execute_zran301;
      	zran3(v, n1, n2, n3, nx[lt-1], ny[lt-1]);
				mace::map<Position, double> zran3_results;
				int i1, i2, i3;
				for(i1=0; i1<n1; i1++){
					for(i2=0; i2<n2; i2++){
						for(i3=0; i3<n3; i3++){
							if(v[i1][i2][i3]!=0){
								Position	p;
								p.x = (uint64_t)i1;
								p.y = (uint64_t)i2;
								p.z = (uint64_t)i3;

								zran3_results[p] = v[i1][i2][i3];
							}	
						}	
					}	
				}

				for(i1=0; i1<CONTEXTS_NUM; i1++){
					for(i2=0; i2<CONTEXTS_NUM; i2++){
						for(i3=0; i3<CONTEXTS_NUM; i3++){
							async_assign_zran3_results(i1, i2, i3, zran3_results);
						}	
					}	
				}
				
			}else{
				cur_state = execute_zran301;	
			}

    }

		async [Element<x, y, z>] assign_zran3_results(int x, int y, int z, mace::map<Position, double>& zran3_results){
			zero3(v, 0, 0, 0, n1, n2, n3);
			mace::map<Position, double>::iterator iter = zran3_results.begin();
			for(; iter!=zran3_results.end(); iter++){
				Position p = iter->first;
				v[p.x][p.y][p.z] = iter->second;
			}

			if(cur_state == execute_zran301){
				cur_state = execute_resid01;
				Identifier id;
				id.pos = pos;
				pre_resid(scl, round, U_FLAG, 0, 0, 0, V_FLAG, 0, 0, 0, R_FLAG, 0, 0, 0, n1, n2, n3, id);
			}else if(cur_state == execute_zran302){
				cur_state = execute_resid03;
        Identifier id;
        id.pos = pos;
        pre_resid(scl, round, U_FLAG, 0, 0, 0, V_FLAG, 0, 0, 0, R_FLAG, 0, 0, 0, n1, n2, n3, id);
			}
		}

    async [Element<x, y, z>] val_updated(int x, int y, int z, mace::map<Position, double>& required_vars, 
					mace::deque<double>& vars){
        if(cur_state == mg3P_loop01_rprj3){
            int k = loop_indicator.pop();
            int j = k-1;
						update_eles(required_vars,  r);

						rprj3(scl, round, r, R_FLAG, ir[0][k], ir[1][k], ir[2][k], m1[k], m2[k], m3[k], r, R_FLAG, ir[0][j], ir[1][j], ir[2][j], m1[j], m2[j], m3[j]);
            round++;
						k--;
            if(k>=lb){
                loop_indicator.push_back(k);
                Identifier id;
                id.pos = pos;
                pre_rprj3(scl, round, r, R_FLAG, ir[0][k], ir[1][k], ir[2][k], m1[k], m2[k], m3[k], r, R_FLAG, ir[0][j], ir[1][j], ir[2][j], m1[j], 
                    m2[j], m3[j], id);
            }else{
                k = lb-1;
                zero3(u, ir[0][k], ir[1][k], ir[2][k], m1[k], m2[k], m3[k]);
                cur_state = mg3P_psinv01;
                Identifier id;
                id.pos = pos;
                pre_psinv(scl, round, R_FLAG, ir[0][k], ir[1][k], ir[2][k], U_FLAG, ir[0][k], ir[1][k], ir[2][k], m1[k], m2[k], m3[k], k, id);
            }
        }else if(cur_state == mg3P_psinv01){
            int k = (int)vars.pop_front();
						update_eles(required_vars,  r);
            psinv(scl, round, r, R_FLAG, ir[0][k], ir[1][k], ir[2][k], u, U_FLAG, ir[0][k], ir[1][k], ir[2][k], m1[k], m2[k], m3[k], c);
						round++;
            k = lb;
            int j = k-1;
            zero(u, ir[0][k], ir[1][k], ir[2][k], m1[k], m2[k], m3[k]);
            cur_state = mg3P_loop02_interp01;
            loop_indicator.push(k);
            Identifier id;
            id.pos = pos;
            pre_interp(scl, round, U_FLAG, ir[0][j], ir[1][j], ir[2][j], m1[j], m2[j], m3[j], U_FLAG, ir[0][k], ir[1][k], ir[2][k], m1[k], m2[k], m3[k], id);
        }else if(cur_state == mg3P_loop02_interp01){
            int k = loop_indicator.pop();
            int j = k-1;
						update_eles(required_vars, u);
            interp(scl, round, u, U_FLAG, ir[0][j], ir[1][j], ir[2][j], m1[j], m2[j], m3[j], u, U_FLAG, ir[0][k], ir[1][k], ir[2][k], m1[k], m2[k], m3[k]);
            round++;
						cur_state = mg3P_loop02_resid01;
            Identifier id;
            id.pos = pos;
            pre_resid(scl, round, U_FLAG, ir[0][k], ir[1][k], ir[2][k], R_FLAG, ir[0][k], ir[1][k], ir[2][k], R_FLAG, ir[0][k], ir[1][k], ir[2][k],
                m1[k], m2[k], m3[k], id);
        }else if(cur_state == mg3P_loop02_resid01){
            int k = loop_indicator.pop();;
            int j = k-1;
						update_eles(required_vars, u);
            resid(scl, round, u, U_FLAG, ir[0][k], ir[1][k], ir[2][k], r, R_FLAG, ir[0][k], ir[1][k], ir[2][k], r, R_FLAG, ir[0][k], ir[1][k], ir[2][k],
                m1[k], m2[k], m3[k], a);
						round++;
            cur_state = mg3P_loop02_psinv;
            Identifier id;
            id.pos = pos;
            pre_psinv(scl, round, R_FLAG, ir[0][k], ir[1][k], ir[2][k], U_FLAG, ir[0][k], ir[1][k], ir[2][k], m1[k], m2[k], m3[k], k, id);
        }else if(cur_state == mg3P_loop02_psinv01){
            int k = loop_indicator.pop();
            int j = k-1;
						update_eles(required_vars, r);
            psinv(scl, round, r, R_FLAG, ir[0][k], ir[1][k], ir[2][k], u, U_FLAG, ir[0][k], ir[1][k], ir[2][k], m1[k], m2[k], m3[k], c);
            round++;
						k++;
            if(k<=lt-2){
                zero3(u, ir[0][k], ir[1][k], ir[2][k], m1[k], m2[k], m3[k]);
                cur_state = mg3P_loop2_interp01;
                Identifier id;
                id.pos = pos;
                pre_interp(scl, round, U_FLAG, ir[0][j], ir[1][j], ir[2][j], m1[j], m2[j], m3[j], U_FLAG, ir[0][k], ir[1][k], ir[2][k], 
                    m1[k], m2[k], m3[k], k, id);
            }else{
                int j = lt - 2;
                k = lt - 1;
                cur_state = mg3P_interp01;
                Identifier id;
                id.pos = pos;
                pre_interp(scl, round, U_FLAG, ir[0][j], ir[1][j], ir[2][j], m1[j], m2[j], m3[j], U_FLAG, 0, 0, 0, n1, n2, n3, k, id);
            }
        }else if(cur_state == mg3P_interp01){
            int k = (int)vars.pop_front();
            int j = k-1;
						update_eles(required_vars, u);
            
						interp(scl, round, u, U_FLAG, ir[0][j], ir[1][j], ir[2][j], m1[j], m2[j], m3[j], u, U_FLAG, 0, 0, 0, n1, n2, n3);
            round++;
						cur_state = mg3P_resid01;
            Identifier id;
            id.pos = pos;
            pre_resid(scl, round, U_FLAG, 0, 0, 0, V_FLAG, 0, 0, 0, R_FLAG, 0, 0, 0, n1, n2, n3, id);
        }else if(cur_state == mg3P_resid01){
            update_eles(required_vars,  u);
            resid(scl, round, u, U_FLAG, 0, 0, 0, v, V_FLAG, 0, 0, 0, r, R_FLAG, 0, 0, 0, n1, n2, n3, a);
            round++;
						cur_state = mg3P_psinv02;
            Identifier id;
            id.pos = pos;
            pre_psinv(scl, round, R_FLAG, 0, 0, 0, U_FLAG, 0, 0, 0, n1, n2, n3, k, id);
        }else if(cur_state == mg3P_psinv02){
            int k = (int)vars.pop_front();
            update_eles(required_vars,  r);
            
            psinv(scl, round, R_FLAG, 0, 0, 0, U_FLAG, 0, 0, 0, n1, n2, n3, c);
            round++;
						async_pos_mg3P(x, y, z);
        }else if(cur_state == execute_resid01){
            update_eles(required_vars, u);
            resid(scl, round, u, U_FLAG, 0, 0, 0, v, V_FLAG, 0, 0, 0, r, R_FLAG, 0, 0, 0, n1, n2, n3, a);
            round++;
						mg3P_state = execute_mg3P01;
            async_pre_mg3P(x, y, z, n1, n2, n3);
        }else if(cur_state == execute_resid02){
            update_eles(required_vars,  u);
            resid(scl, round, u, U_FLAG, 0, 0, 0, v, V_FLAG, 0, 0, 0, r, R_FLAG, 0, 0, 0, n1, n2, n3, a);
            round++;
						zero3(u, 0, 0, 0, n1, n2, n3);

						if(x==0 && y==0 && z==0 ){
							cur_state = execute_zran302;
      				zran3(v, n1, n2, n3, nx[lt-1], ny[lt-1]);
							mace::map<Position, double> zran3_results;
							int i1, i2, i3;
							for(i1=0; i1<n1; i1++){
								for(i2=0; i2<n2; i2++){
									for(i3=0; i3<n3; i3++){
										if(v[i1][i2][i3]!=0){
											Position	p;
											p.x = i1;
											p.y = i2;
											p.z = i3;

											zran3_results[p] = v[i1][i2][i3];
										}	
									}	
								}	
							}

							for(i1=0; i1<CONTEXTS_NUM; i1++){
								for(i2=0; i2<CONTEXTS_NUM; i2++){
									for(i3=0; i3<CONTEXTS_NUM; i3++){
										async_assign_zran3_results(i1, i2, i3, zran3_results);
									}	
								}	
							}
				
					}else{
						cur_state = execute_zran302;	
					}

        }else if(cur_state == execute_resid03){
            update_eles(required_vars, u);
            resid(scl, round, u, U_FLAG, 0, 0, 0, v, V_FLAG, 0, 0, 0, r, R_FLAG, 0, 0, 0, n1, n2, n3, a);
            round++;
						mg3P_state = execute_loop01_mg3P01;
            int k = 1;
            loop_indicator.push(k);
            async_pre_mg3P(x, y, z, n1, n2, n3)
        }else if(cur_state == execute_loop01_resid01){
            update_eles(required_vars, u);
						resid(scl, round, u, U_FLAG, 0, 0, 0, v, V_FLAG, 0, 0, 0, r, R_FLAG, 0, 0, 0, n1, n2, n3, a);
            round++;
						int loop = loop_indicator.pop();
            loop ++;
            if(loop<=nit){
                mg3P_state = execute_loop01_mg3P01;
                loop_indicator.push(loop)
                async_pre_mg3P(x, y, z, n1, n2, n3);    
            }
                    
            
        }
    }

    async [Element<x, y, z>] pre_mg3P(int x, int y, int z, int n1, int n2, int n3){
        int k, j;

        k = lt-1;
        j = k-1;
        cur_state = mg3P_loop01_rprj301;
        loop_indicator.push_back(k);
        Identifier id;
        id.pos = pos;
        pre_rprj3(scl, round, R_FLAG, ir[0][k], ir[1][k], ir[2][k], m1[k], m2[k], m3[k], R_FLAG, ir[0][j], ir[1][j], ir[2][j], m1[j], m2[j], m3[j], k, id);
    }

    async [Element<x, y, z>] post_mg3P(int x, int y, int z){
        Identifier id;
        id.pos = pos;
        if(mg3P_state == execute_mg3P01){
            cur_state = execute_resid02;
            pre_resid(scl, round, U_FLAG, 0, 0, 0, V_FLAG, 0, 0, 0, R_FLAG, 0, 0, 0, n1, n2, n3, id);
        }else if(mg3P_state == execute_loop01_mg3P01){
            cur_state = execute_loop01_resid01;
            pre_resid(scl, round, U_FLAG, 0, 0, 0, V_FLAG, 0, 0, 0, R_FLAG, 0, 0, 0, n1, n2, n3, id);
        }    
    }
}

routines {
	[__null] void add_ele(mace::deque<Position>& required_vars, mace::deque<int>& vars_flags, mace::deque<uint64_t>& vars_rounds, 
			int x, int y, int z, int flag, uint64_t round, Scale scl, mace::map<Postion, int>& check_map){
		if(x<scl.Xmin || x>scl.Xmax || y<scl.Ymin || y>scl.Ymax || x<scl.Zmin || y>scl.Zmax){
    	if(x<1) x=NXYZ_DEFAULT;
			else if(x>NXYZ_DEFAULT) x=0;

			if(y<1) y=NXYZ_DEFAULT;
			else if(y>NXYZ_DEFAULT) y=0;
	
			if(z<1) z=NXYZ_DEFAULT;
			else if(z>NXYZ_DEFAULT) z=0;

			Position pos;
			pos.x = x;
			pos.y = y;
			pos.z = z;

			if(check_map.find(pos)==check_map.end()){
				required_vars.push_back(pos);
				vars_flags.push_back(flag);
				vars_rounds.push_back(round);

				check_map[pos] = 1;
			}
	}

	[__null] void update_eles(mace::map<Position, double>& required_vars, double[][][] matrix){
		mace::map<Position, double>::iterator iter = required_vars.begin();
		for(; iter!=required_vars.end(); iter++){
			Position pos = iter->first;

			if(pox.x == 1) pos.x = NXYZ_DEFAULT+1;
			else if(pos.x == NXYZ_DEFAULT) pos.x = 0;
			
			if(pox.y == 1) pos.y = NXYZ_DEFAULT+1;
			else if(pos.y == NXYZ_DEFAULT) pos.y = 0;

			if(pox.z == 1) pos.z = NXYZ_DEFAULT+1;
			else if(pos.z == NXYZ_DEFAULT) pos.z = 0;

			matrix[pos.x][pos.y][pos.z] = iter->second;
		}
	}

	/****************************************************
	resid computes the residual: r = v - Au
	 ****************************************************/
	[__null] void pre_resid(Scale scl, uint64_t round, int u_flag, int ui1, int ui2, int ui3, int v_flag, int vi1, int vi2, int vi3, int r_flag, int ri1, int ri2, 
            int ri3, int n1, int n2, int n3, Identifier id){
		int i1, i2, i3;

	  mace::deque<Position> required_vars;
		mace::deque<int> vars_flags; 
		mace::deque<uint64_t> vars_rounds;
    mace::deque<double> vars;
		mace::map<Position, int> check_map;

    int start1 = max(0, scl.Xmin-ri1-1);
    int end1 = min(n1, scl.Xmax-ri1+2);
    int start2 = max(1, scl.Ymin-ri2);
    int end2 = min(n2-1, scl.Ymax-ri2+1);
    int start3 = max(1, scl.Zmin-ri3);
    int end3 = min(n3-1, scl.Zmax-ri3+1);
				
		for(i3=start3; i3<end3; i3++){
			for(i2=start2; i2<end2; i2++){
				for(i1=start1; i1<end1; i1++){
        	int x, y, z;
          x = i1+vi1;
          y = i2+vi2;
          z = i3+vi3;
					add_ele(required_vars, vars_flags, vars_rounds, x, y, z, flag, round, scl, check_map);

					int i2_iter, i3_iter;
					for(i3_iter=i3-1; i3_iter<=i3+1; i3_iter++){
						for(i2_iter=i2-1; i2_iter<=i2+1; i2_iter++){
            	int x = i1+ui1;
              int y = i2_iter+ui2;
              int z = i3_iter+ui3;
							add_ele(required_vars, vars_flags, vars_rounds, x, y, z, flag, round, scl, check_map);
	                       
						}	
					}
				}

			}	
		}

		downcall_add_barrier(required_vars, vars_flags, vars_rounds, vars, id);
	}
		 
	[__null] void resid(Scale scl, uint64_t round, double[][][] u, int u_flag, int ui1, int ui2, int ui3, double[][][] v, int v_flag, int vi1, int vi2, int vi3, 
            double[][][] r, int r_flag, int ri1, int ri2, int ri3, int n1, int n2, int n3, double[] a){
	    int i3, i2, i1;
				      
		
		double u1[NXYZ_DEFAULT/CONTEXTS_NUM+2], u2[NXYZ_DEFAULT/CONTEXTS_NUM+2];

        int start1 = max(0, scl.Xmin-ri1-1);
        int end1 = min(n1, scl.Xmax-ri1+2);
        int start2 = max(1, scl.Ymin-ri2);
        int end2 = min(n2-1, scl.Ymax-ri2+1);
        int start3 = max(1, scl.Zmin-ri3);
        int end3 = min(n3-1, scl.Zmax-ri3+1)

		for(i3=start3; i3<end3; i3++){ 
		    for(i2=start2; i2<end2; i2++){
			    for(i1=start1; i1<end1; i1++){
				    u1[i1] = u[i1+ui1][i2-1+ui2][i3+ui3] + u[i1+ui1][i2+1+ui2][i3+ui3] + u[i1+ui1][i2+ui2][i3-1+ui3] + u[i1+ui1][i2+ui2][i3+1+ui3];
					u2[i1] = u[i1+ui1][i2-1+ui2][i3-1+ui3] + u[i1+ui1][i2+1+ui2][i3-1+ui3] + u[i1+ui1][i2-1+ui2][i3+1+ui3] + u[i1+ui1][i2+1+ui2][i3+1+ui3];
				}										

				for(i1=start1+1; i1<end1-1; i1++){
					r[i1+ri1][i2+ri2][i3+ri3] = v[i1+vi1][i2+vi2][i3+vi3] - a[0] * u[i1+ui1][i2+ui2][i3+ui3] - a[2] * ( u2[i1] + u1[i1-1] + u1[i1+1] )
					              - a[3] * ( u2[i1-1] + u2[i1+1] );
				}
			}
        }

		mace::deque<Position> idxes;
		mace::deque<double> vals;
		for(i3=start3; i3<end3; i3++){
		    for(i2=start2; i2<end2; i2++){
			    for(i1=start1; i1<end1; i1++){
				    Position pos;
					pos.z = i3+ri1;
					pos.y = i2+ri2;
					pos.x = i1+ri3;
					idxes.push_back(pos);
					vals.push_back(r[pos.x][pos.y][pos.z]);
				}	
			}	
		}	
		downcall_update_value(idxes, vals, r_flag, round);
				
	}
	
	
	/****************************************************
	 *	rprj3 projects onto the next coarser grid,
	 *	using a trilinear Finite Element projection:  s = r' = P r
	 ****************************************************/
    [__null] void pre_rprj3(Scale scl, uint64_t round, double[][][] r, int r_flag, int ri1, int ri2, int ri3, int m1k, int m2k, int m3k, double[][][] s, int s_flag, 
            int si1, int si2, int si3, int m1j, int m2j, int m3j, Identifier id){
        int j3,  j2,  j1,  i3,  i2,  i1,  d1,  d2,  d3,  j;
            
        if(m1k == 3) d1 = 2;
        else d1 = 1;
             
        if(m2k == 3) d2 = 2;
        else d2 = 1;
             
        if(m3k == 3) d3 = 2;
        else d3 = 1;
             
        mace::deque<Position> required_vars;
        mace::deque<int> vars_flags; 
        mace::deque<uint32_t> vars_rounds;

        mace::deque<double> vars;
				mace::map<Position, int> check_map;

        int start1 = max(0, scl.Xmin-si1-1);
        int end1 = min(m1j, scl.Xmax-si1+2);
        int start2 = max(1, scl.Ymin-si2);
        int end2 = min(m2j-1, scl.Ymax-si2+1);
        int start3 = max(1, scl.Zmin-si3);
        int end3 = min(m3j-1, scl.Zmax-si3+1);
        
        int x, y, z;

        for(j3=start3; j3<end3; j3++){ 
            i3 = 2*j3-d3-1;
            for(j2=start2; j2<end2; j2++){
                i2 = 2*j2-d2-1;
                for(j1=start1; j1<end1; j1++){
                    i1 = 2*j1-d1-1;

                    int i1_iter, i2_iter, i3_iter;

                    for(i1_iter=i1-1; i1_iter<=i1+1; i1_iter++){
                        for(i2_iter=i2-1; i2_iter<=i2+1; i2_iter++){
                            for(i3_iter=i3-1; i3_iter<=i3+1; i3_iter++){
                                if(i1_iter==i1-1 && i2_iter==i2-1 && i3_iter==i3+1) continue;
                                if(i1_iter==i1+1 && (i2_iter!=i2 || i3_iter!=i3)) continue;
                                x = i1_iter+ri1;
                                y = i2_iter+ri2;
                                z = i3_iter+ri3;

																add_ele(required_vars, vars_flags, vars_rounds,  x, y, z, r_flag, round, scl, check_map);
                            }    
                        }
                    }
                }
            }
        }
        downcall_add_barrier(required_vars, vars_flags, vars_rounds, vars, id);
    }

	[__null] void rprj3(Scale scl, uint64_t round, double[][][] r, int r_flag, int ri1, int ri2, int ri3, int m1k, int m2k, int m3k,
	        double[][][] s, int s_flag, int si1, int si2, int si3, int m1j, int m2j, int m3j){
		int j3,  j2,  j1,  i3,  i2,  i1,  d1,  d2,  d3,  j;
		double x1[2*(NXYZ_DEAFULT/CONTEXTS_NUM+2)], y[2*(NXYZ_DEAFULT/CONTEXTS_NUM+2)], x2, y2;
		
	    if(m1k == 3) d1 = 2;
		else d1 = 1;
									
		if(m2k == 3) d2 = 2;
		else d2 = 1;
									
		if(m3k == 3) d3 = 2;
		else d3 = 1;

        int start1 = max(0, scl.Xmin-si1-1);
        int end1 = min(m1j, scl.Xmax-si1+2);
        int start2 = max(1, scl.Ymin-si2);
        int end2 = min(m2j-1, scl.Ymax-si2+1);
        int start3 = max(1, scl.Zmin-si3);
        int end3 = min(m3j-1, scl.Zmax-si3+1);
			
		for(j3=start3; j3<end3; j3++){ 
		    i3 = 2*j3-d3-1;
            for(j2=start2; j2<end2; j2++){
			    i2 = 2*j2-d2-1;
				for(j1=start1; j1<end1; j1++){
				    i1 = 2*j1-d1;
                    x1[i1-1] = r[i1-1+ri1][i2-1+ri2][i3+ri3] + r[i1-1+ri1][i2+1+ri2][i3+ri3] + r[i1-1+ri1][i2+ri2][i3-1+ri3] + r[i1-1+ri1][i2+ri2][i3+1+ri3];
                    y1[i1-1] = r[i1-1+ri1][i2-1+ri2][i3-1+ri3] + r[i1-1+ri1][i2-1+ri2][i3+1+ri3] + r[i1-1+ri1][i2+1+ri2][i3-1+ri3] 
                            + r[i1-1+ri1][i2+1+ri2][i3+1ri3];
				}
                for(j1=start1; j1<end1-1; j1++){
                    i1 = 2*j1-d1;
                    int ele_x = ri1 + i1;
                    int ele_y = ri2 + i2;
                    int ele_z = ri3 + i3;
                    
					y2 = r[ele_x][ele_y-1][ele_z-1] + r[ele_x][ele_y-1][ele_z+1] + r[ele_x][ele_y+1][ele_z-1] + r[ele_x][ele_y+1][ele_z+1];
					x2 = r[ele_x][ele_y-1][ele_z] + r[ele_x][ele_y+1][ele_z] + r[ele_x][ele_y][ele_z-1] + r[ele_x][ele_y][ele_z+1];
					s[si1+j1][si2+j2][si3+j3] = 0.5 * r[ele_x][ele_y][ele_z] + 0.25 * ( r[ele_x-1][ele_y][ele_z] + r[ele_x+1][ele_y][ele_z] + x2) + 0.125 * 
                                ( x1[i1-1] + x1[i1+1] + y2) + 0.0625 * ( y1[i1-1] + y1[i1+1] );
                }
            }
        }

        mace::deque<Position> idxes;
        mace::deque<double> vals;
        for(j3=start3; j3<end3; j3++){
            for(j2=start2; j2<end2; j2++){
                for(j1=start1; j1<end1-1; j1++){
                    Position pos;
                    pos.z = j3+si1;
                    pos.y = j2+si2;
                    pos.x = j1+si3;
                    idxes.push_back(pos);
                    vals.push_back(s[pos.x][pos.y][pos.z]);
                }
            }
        }
        downcall_update_value(idxes, vals, s_flag, round);

	}				
		
	/****************************************************
	 *	interp adds the trilinear interpolation of the correction
	 *	from the coarser grid to the current approximation:  u = u + Qu'
	 ****************************************************/
    [__null] void pre_interp(Scale scl, uint64_t round, int z_flag, int ir1m, int ir2m, int ir3m, int mm1, int mm2, int mm3, 
            int u_flag, int ir1n, int ir2n, int ir3n, int n1, int n2, int n3, int k, Identifier id){
        int i3, i2, i1, d1, d2, d3, t1, t2, t3;

        mace::deque<Position> required_vars;
        mace::deque<int> vars_flags; 
        mace::deque<uint64_t> vars_rounds;
        mace::deque<double> vars;

				mace::map<Postion, int> check_map;

        vars.push_back(k);


        if( n1!=3 && n2!=3 && n3!=3 ){
            int start1 = max(0, (scl.Xmin-ir1n+1)/2);
            int end1 = min(mm1, (scl.Xmax+1-ir1n+1)/2+1);

            int start2 = max(0, (scl.Ymin-ir2n+1)/2);
            int end2 = min(mm2-1, (scl.Ymax-ir2n+1)/2+1);

            int start3 = max(0, (scl.Zmin-ir3n+1)/2);
            int end3 = min(mm3-1, (scl.Zmax-ir3n+1)/2+1);
            for(i3=start3; i3<end3; i3++){
                for(i2=start2; i2<end2; i2++){
                    for(i1=start1; i1<=end1; i1++){
                        int i1_iter, i2_iter, i3_iter, x, y, z;
                        i1_iter = i1;
                        for(i2_iter=i2; i2_iter<=i2+1; i2_iter++){
                            for(i3_iter=i3; i3_iter<=i3+1; i3_iter++){
                                x = i1_iter+ir1m;
                                y = i2_iter+ir2m;
                                z = i3_iter+ir3m;
																add_ele(required_vars, vars_flags, vars_rounds, x, y, z, z_flag, round, scl, check_map);
                            }
                            
                        }
                        
                        x = i1+1;
                        y = i2;
                        z = i3;
												add_ele(required_vars, vars_flags, vars_rounds, x, y, z, z_ flag, round, scl, check_map);
                    }
                }
                downcall_add_barrier(required_vars, vars_flags, vars_rounds, vars);
            }else{
                if(n1 == 3){
                    d1 = 2;
                    t1 = 1;
                }else{
                    d1 = 1;
                    t1 = 0;
                }
                 
                if(n2 == 3){
                    d2 = 2;
                    t2 = 1;
                }else{
                    d2 = 1;
                    t2 = 0;
                }
                 
                if(n3 == 3){
                    d3 = 2;
                    t3 = 1;
                }else{
                    d3 = 1;
                    t3 = 0;
                }

                int start1, end1, start2, end2, start3, end3;
                start1 = min(d1, 0);
                start1 = max(start1, (scl.Xmin-1-ir1n+t1)/2);
                end1 = min(mm1-1, (scl.Xmax-ir1n+d1)/2+1);
                 
                start2 = min(d2, 0);
                start2 = max(start2, (scl.Ymin-1-ir2n+t2)/2);
                end2 = min(mm2-1, (scl.Ymax-ir2n+d2)/2+1);
                 
                start3 = min(d3, 0);
                start3 = max(start3, (scl.Zmin-1-ir3n+t3)/2);
                end3 = min(mm3-1, (scl.Zmax-ir3n+d3)/2+1);
                 
                for(i3=start3; i3<end3; i3++){
                    for(i2=start2; i2<end2; i2++){
                        for(i1=start1; i1<end1; i1++){
                            int i1_iter, i2_iter, i3_iter;
                            for(i1_iter = i1; i1_iter<=i1+1; i1_iter++){
                                for(i2_iter = i2; i2_iter<=i2+1; i2_iter++){
                                    for(i3_iter = i3; i3_iter<=i3+1; i3_iter++){
                                        x = i1_iter+ir1m;
                                        y = i2_iter+ir2m;
                                        z = i3_iter+ir3m;
																				add_ele(required_vars, vars_flags, vars_rounds, x, y, z, z_flag, round, scl, check_map);
                                    }    
                                }    
                            }
                        }
                    }
                }
                downcall_add_barrier(required_vars, vars_flags, vars_rounds, vars, id);
            }

        }

        
		[__null] void interp(Scale scl, uint64_t round, double[][][] u, int ir1m, int ir2m, int ir3m, int mm1, int mm2, int mm3, 
                int ir1n, int ir2n, int ir3n, int n1, int n2, int n3){
		    int i3, i2, i1, d1, d2, d3, t1, t2, t3;
            double z1[NXYZ_DEFAULT/CONTEXTS_NUM+2], z2[NXYZ_DEFAULT/CONTEXTS_NUM+2], z3[NXYZ_DEFAULT/CONTEXTS_NUM+2];

            if( n1!=3 && n2!=3 && n3!=3 ){
                int start1 = max(0, (scl.Xmin-ir1n)/2);
                int end1 = min(mm1-1, (scl.Xmax-ir1n)/2+1);

                int start2 = max(0, (scl.Ymin-ir2n)/2);
                int end2 = min(mm2, (scl.Ymax-ir2n)/2+1);

                int start3 = max(0, (scl.Zmin-ir3n)/2);
                int end3 = min(mm3, (scl.Zmax-ir3n)/2+1);

                for(i3=start3; i3<end3; i3++){
                    for(i2=start2; i2<end2; i2++){
                        for(i1=start1; i1<end1; i1++){
                            z1[i1] = u[i1+ir1m][i2+ir2m+1][i3+ir3m] + u[i1+ir1m][i2+ir2m][i3+ir3m];
                            z2[i1] = u[i1+ir1m][i2+ir2m][i3+ir3m+1] + u[i1+ir1m][i2+ir2m][i3+ir3m];
                            z3[i1] = u[i1+ir1m][i2+ir2m+1][i3+ir3m+1] + u[i1+ir1m][i2+ir2m][i3+ir3m+1] + z1[i1];
                        }
                        
                        for(i1=start1; i1<end1-1; i1++){
                            u[2*i1-1+ir1n][2*i2-1+ir2n][2*i3-1+ir3n] = u[2*i1-1+ir1n][2*i2-1+ir2n][2*i3-1+ir3n] + u[i1+ir1m][i2+ir2m][i3+ir3m];
                            u[2*i1+ir1n][2*i2-1+ir2n][2*i3-1+ir3n] = u[2*i1+ir1n][2*i2-1+ir2n][2*i3-1+ir3n] + 0.5*( u[i1+1+ir1m][i2+ir2m][i3+ir3m] 
                                                                    + u[i1+ir1m][i2+ir2m][i3+ir3m] );
                        }
                         
                        for(i1=start1; i1<end1-1; i1++){
                            u[2*i1-1+ir1n][2*i2+ir2n][2*i3-1+ir3n] = u[2*i1-1+ir1n][2*i2+ir2n][2*i3-1+ir3n] + 0.5*z1[i1];
                            u[2*i1+ir1n][2*i2+ir2n][2*i3-1+ir3n] = u[2*i1+ir1n][2*i2+ir2n][2*i3-1+ir3n] + 0.25*( z1[i1] + z1[i1+1] );
                        }
                         
                        for(i1=start1; i1<end1-1; i1++){
                            u[2*i1-1+ir1n][2*i2-1+ir2n][2*i3+ir3n] = u[2*i1-1+ir1n][2*i2-1+ir2n][2*i3+ir3n] + 0.5*z2[i1];
                            u[2*i1+ir1n][2*i2-1+ir2n][2*i3+ir3n] = u[2*i1+ir1n][2*i2-1+ir2n][2*i3+ir3n] + 0.25*( z2[i1] + z2[i1+1] );
                        }
                         
                        for(i1=start1; i1<end1-1; i1++){
                            u[2*i1-1+ir1n][2*i2+ir2n][2*i3+ir3n] = u[2*i1-1+ir1n][2*i2+ir2n][2*i3+ir3n] + 0.25*z3[i1];
                            u[2*i1+ir1n][2*i2+ir2n][2*i3+ir3n]   = u[2*i1+ir1n][2*i2+ir2n][2*i3+ir3n] + 0.125*( z3[i1] + z3[i1+1] );
                        }
                    }
                }

                mace::deque<Position> idxes;
                mace::deque<double> vals;
                for(i3=start3; i3<end3; i3++){
                    for(i2=start2; i2<end2; i2++){
                        for(i1=start1; i1<end1; i1++){
                            int i1_iter, i2_iter, i3_iter;
                            for(i2_iter=i2*2-1; i2_iter<=i2*2; i2_iter++){
                                for(i3_iter=i3*2-1; i3_iter<=i3*2; i3_iter++){
                                    for(i1_iter=i1*2-1; i1_iter<=i1*2; i1_iter++){
                                        Position pos;
                                        pos.z = i3_iter+ir3n;
                                        pos.y = i2_iter+ir2n;
                                        pos.x = i1_iter+ir1n;
                                        idxes.push_back(pos);
                                        vals.push_back(u[pos.x][pos.y][pos.z]);
                                    }
                                }
                            }
                        }
                    }
                }
                downcall_update_value(idxes, vals, U_FLAG, round);

            }else{
                if(n1 == 3){
                    d1 = 2;
                    t1 = 1;
                }else{
                    d1 = 1;
                    t1 = 0;
                }

                if(n2 == 3){
                    d2 = 2;
                    t2 = 1;
                }else{
                    d2 = 1;
                    t2 = 0;
                }

                if(n3 == 3){
                    d3 = 2;
                    t3 = 1;
                }else{
                    d3 = 1;
                    t3 = 0;
                }

                int start1, end1;
                int start2, end2;
                int start3, end3;

                
                start3 = max(d3-1, (scl.Zmin-1-ir3n+d3)/2);
                end3 = min(mm3-1, (scl.Zmax-ir3n+d3)/2+1);
                for(i3=start3; i3<end3; i3++){
                    start2 = max(d2-1, (scl.Ymin-1-ir2n+d2)/2);
                    end2 = min(mm2-1, (scl.Ymax-1-ir2n+d2)/2+1);
                    for(i2=start2; i2<end2; i2++){
                        start1 = max(d1-1, (scl.Xmin-1-ir1n+d1)/2);
                        end1 = min(mm1-1, (scl.Xmax-ir1n+d1)/2+1);
                        for(i1=start1; i1<end1; i1++){
                            u[2*i1-d1+ir1n][2*i2-d2+ir2n][2*i3-d3+ir3n] = u[2*i1-d1+ir1n][2*i2-d2+ir2n][2*i3-d3+ir3n] + u[i1+ir1m][i2+ir2m][i3+ir3m];
                        }
                        
                        start1 = max(0, (scl.Xmin-1-ir1n+t1)/2);
                        end1 = min(mm1-1, (scl.Xmax-ir1n+t1)/2+1);
                        for(i1=start1; i1<end1; i1++){
                            u[2*i1-t1+ir1n][2*i2-d2+ir2n][2*i3-d3+ir3n] = u[2*i1-t1+ir1n][2*i2-d2+ir2n][2*i3-d3+ir3n] + 0.5*(u[i1+1+ir1m][i2+ir2m][i3+ir3m] 
                                                                        + u[i1+ir1m][i2+ir2m][i3+ir3m] );
                        }
                    }

                    start2 = max(0, (scl.Ymin-1-ir2n+t2)/2);
                    end2 = min(mm2-1, (scl.Ymax-ir2n+t2)/2+1);
                    for(i2=start2; i2<end2; i2++){
                        start1 = max(d1-1, (scl.Xmin-1-ir1n+d1)/2);
                        end1 = min(mm1-1, (scl.Xmax-ir1n+d1)/2+1);
                        for(i1=start1; i1<end1; i1++){
                            u[2*i1-d1+ir1n][2*i2-t2+ir2n][2*i3-d3+ir3n] = u[2*i1-d1+ir1n][2*i2-t2+ir2n][2*i3-d3+ir3n] + 0.5*(u[i1+ir1m][i2+1+ir2m][i3+ir3m] 
                                                                        + u[i1+ir1m][i2+ir2m][i3+ir3m] );
                        }
                         
                        start1 = max(0, (scl.Xmin-1-ir1n+t1)/2);
                        end1 = min(mm1-1, (scl.Xmax-ir1n+t1)/2+1);
                        for(i1=start1; i1<end1; i1++){
                            u[2*i1-t1+ir1n][2*i2-t2+ir2n][2*i3-d3+ir3n] = u[2*i1-t1+ir1n][2*i2-t2+ir2n][2*i3-d3+ir3n] + 0.25*(u[i1+1+ir1m][i2+1+ir2m][i3+ir3m] 
                                                                        + u[i1+1+ir1m][i2+ir2m][i3+ir3m] + u[i1+ir1m][i2+1+ir2m][i3+ir3m] 
                                                                        + u[i1+ir1m][i2+ir2m][i3+ir3m] );
                        }
                    }
                }
                
                start3 = max(0, (scl.Zmin-1-ir3n+t3)/2);
                end3 = min(mm3-1, (scl.Zmax-ir3n+t2)/2+1);
                for(i3=start3; i3<end3; i3++){
                    start2 = max(d2-1, (scl.Ymin-1-ir2n+d2)/2);
                    end2 = min(mm2-1, (scl.Ymax-ir2n+d2)/2+1);
                    for(i2=d2; i2<mm2; i2++){
                        start1 = max(d1-1, (scl.Xmin-1-ir1n+d1)/2);
                        end1 = min(mm1-1, (scl.Zmax-ir1n+d1)/2+1);
                        for(i1=start1; i1<end1; i1++){
                            u[2*i1-d1+ir1n][2*i2-d2+ir2n][2*i3-t3+ir3n] = u[2*i1-d1+ir1n][2*i2-d2+ir2n][2*i3-t3+ir3n] + 0.5*(u[i1+ir1m][i2+ir2m][i3+1+ir3m] 
                                                                        + u[i1+ir1m][i2+ir2m][i3+ir3m]);
                        }
                         
                        start1 = max(0, (scl.Xmin-1-ir1n+t1)/2);
                        end1 = min(mm1-1, (scl.Xmax-ir1n+t1)/2+1);
                        for(i1=start1; i1<end1; i1++){
                            u[2*i1-t1+ir1n][2*i2-d2+ir2n][2*i3-t3+ir3n] = u[2*i1-t1+ir1n][2*i2-d2+ir2n][2*i3-t3+ir3n] + 0.25*(u[i1+1+ir1m][i2+ir2m][i3+1+ir3m] 
                                                                        + u[i1+ir1m][i2+ir2m][i3+1+ir3m] + u[i1+1+ir1m][i2+ir2m][i3+ir3m]
                                                                        + u[i1+ir1m][i2+ir2m][i3+ir3m]);
                        }
                    }
                     
                    start2 = max(0, (scl.Ymin-1-ir2n+t2)/2);
                    end2 = min(mm2-1, (scl.Ymax-ir2n+t2)/2+1);
                    for(i2=start2; i2<end2; i2++){
                        start1 = max(d1-1, (scl.Xmin-1-ir1n+d2)/2);
                        end1 = min(mm1-1, (scl.Xmax-ir1n+d2)/2+1);
                        for(i1=start1; i1<end1; i1++){
                            u[2*i1-d1+ir1n][2*i2-t2+ir2n][2*i3-t3+ir3n] = u[2*i1-d1+ir1n][2*i2-t2+ir2n][2*i3-t3+ir3n] + 0.25*(u[i1+ir1m][i2+1+ir2m][i3+1+ir3m] 
                                                                        + u[i1+ir1m][i2+ir2m][i3+1+ir3m] + u[i1+ir1m][i2+1+ir2m][i3+ir3m]
                                                                        + u[i1+ir1m][i2+ir2m][i3+ir3m]);
                        }
        
                        start1 = max(0, (scl.Xmin-1-ir1n+t1)/2);
                        end1 = min(mm1-1, (scl.Xmax-ir1n+t1)/2+1);
                        for(i1=start1; i1<end1; i1++){
                            u[2*i1-t1+ir1n][2*i2-t2+ir2n][2*i3-t3+ir3n] = u[2*i1-t1+ir1n][2*i2-t2+ir2n][2*i3-t3+ir3n] + 0.125*(u[i1+1+ir1m][i2+1+ir2m][i3+1+ir3m] 
                                                                        + u[i1+1+ir1m][i2+ir2m][i3+1+ir3m] + u[i1+ir1m][i2+1+ir2m][i3+1+ir3m] 
                                                                        + u[i1+ir1m][i2+ir2m][i3+1+ir3m] + u[i1+1+ir1m][i2+1+ir2m][i3+ir3m] 
                                                                        + u[i1+1+ir1m][i2+ir2m][i3+ir3m] + u[i1+ir1m][i2+1+ir2m][i3+ir3m] 
                                                                        + u[i1+ir1m][i2+ir2m][i3+ir3m]);
                        }
                    }
                }
               
                mace::deque<Position> idxes;
                mace::deque<double> vals;
                start1 = min(d1-1, 0);
                start1 = max(start1, (scl.Xmin-1-ir1n+t1)/2);
                end1 = min(mm1-1, (scl.Xmax-ir1n+d1)/2+1);

                start2 = min(d2-1, 0);
                start2 = max(start2, (scl.Ymin-1-ir2n+t2)/2);
                end2 = min(mm2-1, (scl.Ymax-ir2n+d2)/2+1);

                start3 = min(d3-1, 0);
                start3 = max(start3, (scl.Zmin-1-ir3n+t3)/2);
                end3 = min(mm3-1, (scl.Zmax-ir3n+d3)/2+1);


                for(i3=start3; i3<end3; i3++){
                    for(i2=start2; i2<end2; i2++){
                        for(i1=start1; i1<end1; i1++){
                            int i1_iter, i2_iter, i3_iter;
                            for(i1_iter=2*i1-d1+ir1n; i1_iter<=2*i1-t1+ir1n; i1_iter++){
                                for(i2_iter=2*i2-d2+ir2n; i2_iter<=2*i2-t2+ir2n; i2_iter++){
                                    for(i3_iter=2*i3-d3+ir3n; i3_iter<=2*i3-t3+ir3n; i3_iter++){
                                        if(scl.Xmin<=i1_iter && i1_iter<=scl.Xmax && scl.Ymin<=i2_iter && i2_iter<=scl.Ymax 
                                                && scl.Zmin<=i3_iter && i3_iter<=scl.Zmax){ 
                                            Position pos;
                                            pos.z = i3_iter;
                                            pos.y = i2_iter;
                                            pos.x = i1_iter;
                            
                                            idxes.push_back(pos);
                                            vals.push_back(u[i1_iter][i2_iter][i3_iter]);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                downcall_update_value(idxes, vals, U_FLAG, round);

            }
        }
                       
                       

                       
                       
                
		
		/****************************************************
		 *	 psinv applies an approximate inverse as smoother:  u = u + Cr
		 *	
		 ****************************************************/
        [__null] void pre_psinv(Scale scl, uint64_t round, int r_flag, int r1, int r2, int r3, int u_flag, int u1, int u2, int u3, 
                int n1, int n2, int n3, int k, Identifier id){
            int i1, i2, i3;

            mace::deque<Position> required_vars;
            mace::deque<int> vars_flags; 
            mace::deque<uint64_t> vars_rounds;
            mace::deque<double> vars;
						mace::map<Position, int> check_map;

            vars.push_back((double)k);

            int start1 = max(0, scl.Xmin-1-u1);
            int end1 = min(n1, scl.Xmax+2-u1);
            int start2 = max(1, scl.Ymin-u2);
            int end2 = min(n2-1, scl.Ymax+1-u2);
            int start3 = max(1, scl.Zmin-u3);
            int end3 = min(n3-1, scl.Zmax+1-u3);

            for(i3=start3; i3<end3; i3++){
                for(i2=start2; i2<end2; i2++){
                    for(i1=start1; i1<end1; i1++){
                        int i1_iter, i2_iter, i3_iter;
                        i1_iter = i1;

                        for(i2_iter=i2-1; i2_iter<=i2+1; i2_iter++){
                            for(i3_iter=i3-1; i3_iter<=i3+1; i3_iter++){
                                if(i2_iter == i2 && i3_iter == i3) continue;
																add_ele(required_vars,  vars_flags,  i1_iter+r1,  i2_iter+r2, i3_iter+r3,  r_flag,  round,  
																	scl,  check_map);

                            }
                        }
                    }

                    i2_iter = i2;
                    i3_iter = i3;

                    for(i1_iter=i1-1; i1_iter<=i1+1; i1_iter++){
                    	add_ele(required_vars,  vars_flags,  vars_rounds, i1_iter+r1, i2_iter+r2,  i3_iter+r3,  r_flag,  round,  
												scl,  check_map);
                    }
                }
            }
            downcall_add_barrier(required_vars, vars_flags, vars_rounds, vars, id);

        }

		[__null] void psinv(Scale scl, uint64_t round, double[][][] r, int r_flag, int ri1, int ri2, int ri3, double [][][] u, int u_flag, int ui1, int ui2, int ui3, 
                int n1, int n2, int n3, double[] c){
		    int i3, i2, i1;

            double r1[NXYZ_DEAULT/CONTEXTS_NUM+2], r2[NXYZ_DEFAULT/CONTEXTS_NUM+2];
            int start1 = max(0, scl.Xmin-1-ui1);
            int end1 = min(n1, scl.Xmax+1-ui1);
            int start2 = max(1, scl.Ymin-ui2);
            int end2 = min(n2-1, scl.Ymax+1-ui2);
            int start3 = max(1, scl.Zmin-ui3);
            int end3 = min(n3-1, scl.Zmax+1-ui3);

            for(i3=start3; i3<end3; i3++){
                for(i2=start2; i2<end3; i2++){
                    for(i1=start1; i1<end3; i1++){
                        r1[i1] = r[i1+ri1][i2-1+ri2][i3+ri3] + r[i1+ri1][i2+1+ri2][i3+ri3] + r[i1+ri1][i2+ri2][i3-1+ri3] + r[i1+ri1][i2+ri2][i3+1+ri3];
                        r2[i1] = r[i1+ri1][i2-1+ir2][i3-1+ri3] + r[i1+ri1][i2+1+ri2][i3-1+ri3] + r[i1+ri1][i2-1+ri2][i3+1+ri3] + r[i1+ri1][i2+1+ir2][i3+1+ir3];
                    }
                     
                    for(i1=start1+1; i1<end1-1; i1++){
                        u[i1+ui1][i2+ui2][i3+ui3] = u[i1+ui1][i2+ui2][i3+ui3] + c[0]*r[i1+ri1][i2+ri2][i3+ri3] + c[1]*( r[i1-1+ri1][i2+ri2][i3+ri3] 
                                                    + r[i1+1+ri1][i2+ri2][i3+ri3] + r1[i1] )
                                                    + c[2] * ( r2[i1] + r1[i1-1] + r1[i1+1] );
                    }
                }
            }

            mace::deque<Position> idxes;
            mace::deque<double> vals;
            for(i3=start3; i3<end3; i3++){
                for(i2=start2; i2<end2; i2++){
                    for(i1=start1+1; i1<end1-1; i1++){
                        Position pos;
                        pos.z = i3+ui1;
                        pos.y = i2+ui2;
                        pos.x = i1+ui3;
                         
                        idxes.push_back(pos);
                        vals.push_back(u[pos.x][pos.y][pos.z]);
                    }
                }
            }
            downcall_update_value(idxes, vals, u_flag, round);
		}				
				
    [__null] void zero3(double[][][] z, int zi1, int zi2, int zi3, int n1, int n2, int n3){
        int i1, i2, i3;

        for(i3=zi1; i3<n3; i3++){
            for(i2=zi2; i2<n2; i2++){
                for(i1=zi3; i1<n1; i1++){
                    z[i1][i2][i3] = 0;    
                }    
            }    
        }
    }

    [__null] void zran3(double[][][] z, int n1, int n2, int n3, int nx, int ny, int k){
        int i;

        for(i=0; i<10; i++){
            int x = random(n1);
            int y = random(n2);
            int z = random(n3);

            z[x][y][z] = 1;
        }

        for(i=0; i<10; i++){
            int x = random(n1);
            int y = random(n2);
            int z = random(n3);

            z[x][y][z] = -1;
        }

    }
}


