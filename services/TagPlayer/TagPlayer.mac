#include "marray.h"
#include "RandomUtil.h"
#include "mvector.h"
#include "mlist.h"
#include "m_map.h"

using std::endl;

service TagPlayer;
 
provides TagPlayer;
 
services {
  Transport t::9000 = auto(shared,[],[]);
 // Transport router = TcpTransport();
}
 
constants {
  //The maximun size that the room can have
  uint16_t MAXIMUM_SIZE = 20;
  uint16_t BUILDING_NUM = 2;
  uint16_t ROOM_NUM = 3;
}
 
states {
  playing;
}
 
#minclude "TagPlayerMessages.mi"

messages {
 
  //instant message with other player
  ChatMsg {
    mace::string message;
  }
 
  
 
  //notify that I am it
  IamIT {
    uint16_t kidID;
    uint16_t role;
    uint16_t x_coordinate;
    uint16_t y_coordinate;
    uint16_t location;
  }
 
}

auto_types {
  player __attribute((comparable(equals = default; lessthan=default))){
    
    uint16_t playerID;
    uint16_t role;
    uint16_t nBuilding;
    uint16_t nRoom;
    uint16_t originalBuilding;
    uint16_t x_coordinate;
    uint16_t y_coordinate;
    uint16_t curDirection;
    uint16_t location;
    uint16_t length;
    uint16_t width;
    mace::array<mace::array<int, MAXIMUM_SIZE>,MAXIMUM_SIZE> roomMap;
  }
}

state_variables {
  MaceKey headAddr;
  
  mace::map<uint16_t,player> Kids;
  mace::vector<MaceKey> peerAddr;
  //MaceKey 
}
 
transitions {
 
  downcall (state==init) maceInit()
  {
   
    headAddr = MaceKey(ipv4, params::get<std::string>("SERVER_ADDR") );
    

    for(int i=1;i<=10;i++)
    { 
      /*player peer;
      peer.playerID = i;
      peer.role = 0;
      peer.location = 1;
      peer.originalBuilding = 0;
      peer.curDirection = i%5;
      Kids.insert(pair<uint16_t,player>(i,peer));*/
      Kids[i].playerID = i;
      Kids[i].role = 0;
      Kids[i].location = 1;
      Kids[i].originalBuilding = 0;
      Kids[i].curDirection = i%5;
      downcall_route(headAddr,RequireInitial(i));
      downcall_route(headAddr,ChangeDirection(Kids[i].curDirection,i));
    }
    //join the game and get the PlayerID
    
    //downcall_movePlayer(curDirection);
    //downcall_route(headAddr,ChangeDirection(curDirection,playerID));
 
 
  }
 
  //recevie ID from server
  upcall deliver(const MaceKey& src, const MaceKey& dest, const ReceiveInitial& msg)
  {
    int i;
    i=msg.kidID;
   
    Kids[i].role = msg.role;
   
    settheRoom(i,RandomUtil::randInt(BUILDING_NUM),RandomUtil::randInt(ROOM_NUM));
  }
 
 
  //Require Room Map
  downcall requireRoomMap(uint16_t id,uint16_t nBuilding,uint16_t nRoom)
  {
    downcall_route(headAddr,RequireRoomInfo(id,nBuilding, nRoom));
  }
 
  //move player
  downcall movePlayer(uint16_t id,uint16_t direction) {
    Kids[id].curDirection = direction;
    downcall_route(headAddr,ChangeDirection(Kids[id].curDirection,id));
  }
 
  //user decides to change to other room
  downcall changeRoom(uint16_t id,uint16_t newBuilding, uint16_t newRoom)
  {
    Kids[id].originalBuilding = Kids[id].nBuilding;
    Kids[id].nBuilding = newBuilding;
    Kids[id].nRoom = newRoom;

    downcall_route(headAddr,ChangeRoom( Kids[id].originalBuilding ,newBuilding,newRoom,id));

    
  }
 
  //check how many kids in certain room
  downcall checkKidNum(uint16_t nBuilding, uint16_t nRoom)
  {
    downcall_route(headAddr,CheckKidNum(nBuilding, nRoom));
  }
 
  //send the message to other player
  downcall sendmsg(uint16_t id)
  {
    MaceKey dest = peerAddr[id];
    downcall_route(dest,ChatMsg("Hello"));
  }
 
 
  
 
 
 
  //receive the room information that I am there
  upcall deliver(const MaceKey& src, const MaceKey& dest, const ReceivePosition& msg)
  {
    uint16_t i;
    i = msg.kidID;
    //role = msg.role;  
    Kids[i].location = 0;
    Kids[i].x_coordinate = msg.x_coordinate;
    Kids[i].y_coordinate = msg.y_coordinate;
    //downcall_requireRoomMap(nBuilding, nRoom);
    Kids[i].nBuilding = msg.nBuilding;
    Kids[i].nRoom = msg.nRoom;
    downcall_route(headAddr,RequireRoomInfo(i,Kids[i].nBuilding, Kids[i].nRoom));
  }
 
  //receive new position after every movement
  upcall (state==playing) deliver(const MaceKey& src, const MaceKey& dest, const ReceivePosition& msg)
  {
    uint16_t i;
    i = msg.kidID;
    //role = msg.role;  
    Kids[i].location = 0;
    Kids[i].x_coordinate = msg.x_coordinate;
    Kids[i].y_coordinate = msg.y_coordinate;
    //downcall_requireRoomMap(nBuilding, nRoom);
    Kids[i].nBuilding = msg.nBuilding;
    Kids[i].nRoom = msg.nRoom;
  }
 
 
 
  //Receive the room Map
  upcall deliver(const MaceKey& src, const MaceKey& dest, const ReceiveRoomInfo& msg)
  {
    int i,j;
    uint16_t id;
    id = msg.kidID;
    Kids[id].length = msg.length;
    Kids[id].width = msg.width;
    for(i=0;i<Kids[id].length;i++)
    {
      for(j=0;j<Kids[id].width;j++)
      {
        Kids[id].roomMap[i][j]= msg.map[i][j];
      }
    }
    //state=playing;
  }
 
  //receive the message that I am it and send the command to go to a new room
  upcall deliver(const MaceKey& src, const MaceKey& dest, const IamIT& msg)
  {
    uint16_t id;
    id = msg.kidID;
   
    if(msg.role==1)
    {
      Kids[id].x_coordinate = msg.x_coordinate;
      Kids[id].y_coordinate = msg.y_coordinate;
      Kids[id].role = msg.role;
      Kids[id].location = msg.location;
    }
   
    settheRoom(id,RandomUtil::randInt(BUILDING_NUM),RandomUtil::randInt(ROOM_NUM));
  }
 
 
 
  upcall deliver(const MaceKey& src, const MaceKey& dest, const KidNumReply& msg)
  {
    upcall_printkidNum(msg.kidNum);
  }
 
 
  //reveice and print the message
  upcall deliver(const MaceKey& src, const MaceKey& dest, const ChatMsg& msg)
  {
    upcall_printmsg(msg.message);
  }
}

routines {
  
   //move into a room
  void settheRoom(uint16_t id, uint16_t Building, uint16_t Room) {
    uint16_t original;
    original = Kids[id].originalBuilding;
    Kids[id].nBuilding = Building;
    Kids[id].nRoom = Room;
    if(Kids[id].location==1){
      downcall_route(headAddr,RequirePosition(id,original, Building, Room));
    }
  }
}
