/* 
 * MPI.mac : part of the Mace toolkit for building distributed systems
 * 
 * Copyright (c) 2011, Wei-Chiu Chuang, Charles Killian, James W. Anderson
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the names of the contributors, nor their associated universities 
 *      or organizations may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * ----END-OF-LEGAL-STUFF---- 
*/

#include "mlist.h"
#include "marray.h"
#include "mdeque.h"

using mace::NodeCollection;

service GameOfLife;
//provides GenericGameOfLife;
trace = med;

constants{
		uint64_t RESEND_TIMEOUT = 0.5*1000*1000; 
		int JOINED_NODE_NUM=4 ;
}

services {
    Transport tcp = TcpTransport();
}

states {
		
		WaitingResults;		//Master is waiting for compute results from workers

		Ready;			//Workers: have finished computation
		Computing;		//Workers: are computing
    	
}

constructor_parameters {
		// Master: the number of workers
}

auto_types {
		Position __attribute((comparable(equals=default; lessthan=default))) {
				int x;
				int y;
		}
}

typedefs {
    typedef mace::map<Position, int> PositionValueMap;
		
}

state_variables {
	//	timer _resend_timer;

		PositionValueMap _monitor_positionValueMap;
		int _elements_totalnum;
		int _elements_curnum;

		context Row<uint32_t row>{
				context Column<uint32_t column>{
						int _myValue;	
						int _curcount;
						int _totalcount;
						int _matrix;
						PositionValueMap _positionValueMap;

						int _round;
					
				}
		}

}


local_address {
  			return downcall_localAddress();
}

messages {
		MonitorMsg { mace::string msg; }
		ValueMsg { Position p; int value; }
}

transitions {

	/*
		scheduler _resend_timer() {
				mace::map<MaceKey,  mace::map<uint32_t,  mace::string> >::iterator iter;
				for(iter=__internal_unAck.begin(); iter!=__internal_unAck.end(); iter++){
						mace::map<uint32_t,  mace::string>::iterator msg_iter;
						for(msg_iter=(iter->second).begin(); msg_iter!=(iter->second).end(); msg_iter++){
								std::istringstream in( msg_iter->second);
								switch(Message::getType(msg_iter->second) ){
										case __async_at1_initialize::messageType:{
												__async_at1_initialize msg;
												mace::deserialize(in,  &msg);
												downcall_route(iter->first,  msg);
										}
												break;
										case __async_at2_storeValue::messageType:{
												__async_at2_storeValue msg;
												mace::deserialize(in,  &msg);
												downcall_route(iter->first,  msg);
										}
												break;
										default:{
												maceerr << "Unrecognized message type id: " << Message::getType(msg_iter->second) << Log::endl;	
										}
								}
						}
				}
				_resend_timer.reschedule(RESEND_TIMEOUT);
		}
*/
  	downcall (state == init) maceInit() {
				if( params::containsKey("monitor") && MaceKey(ipv4,  params::get<std::string>("monitor"))==localAddress() ){
						std::cout<<"[monitor] monitor start!"<<std::endl;
						_elements_curnum=0;
						if(params::containsKey("elements_num")){
								_elements_totalnum=params::get<int>("elements_num");	
						}else{
								_elements_totalnum=10;	
						}
				}else{	
      			if( ContextMapping::getNodeByContext("") == localAddress() ){
								initialize(0,  0,  0,  0 );	
						}
						resender_timer.reschedule(RESEND_TIMEOUT);
				}
  	}

  	downcall (state != init) maceExit() {
					      			
  	}

		upcall deliver(const MaceKey& from,  const MaceKey& dest,  const MonitorMsg& msg){
				std::cout<<"[monitor]"<<msg.msg<<std::endl;				
		}

		upcall deliver(const MaceKey& from,  const MaceKey& dest,  const ValueMsg& msg){
				_monitor_positionValueMap[msg.p]=msg.value;
				_elements_curnum++;
				if(_elements_curnum == _elements_totalnum * _elements_totalnum){
						show_results(_monitor_positionValueMap,  _elements_totalnum);
						_elements_curnum=0;
				}
		}

  async [Row<row>::Column<column>] initialize( int row,  int column, int value ,  int matrix) {
			std::cout<<"Context Row["<<row<<"]Column["<<column<<"] Start to initialize!"<<std::endl;
			Row[row].Column[column]._matrix=0;
			Row[row].Column[column]._totalcount=0;
			Row[row].Column[column]._curcount=0;
			Row[row].Column[column]._round=1;
			if(row==0 && column==0){
					mace::string str="Master has started!";
					if(params::containsKey("monitor")){
							downcall_route(MaceKey(ipv4,  params::get<std::string>("monitor")), MonitorMsg(str) );
					}

					std::ifstream in("initstate.txt");
					int x=1;
					int y=1;
			 
					char buf[1024];
					while( !in.eof() ){
							y=1; 
							in.getline(buf, 1024);
							int len=std::strlen(buf);
							for(int i=0; i<len; i++,  y++){
									Position p;
									p.x=x;
									p.y=y;
									if(buf[i]=='0'){
											Row[row].Column[column]._positionValueMap[p]=0;
									}else if(buf[i]=='1'){
											Row[row].Column[column]._positionValueMap[p]=1;
									}
							}
							if(Row[row].Column[column]._matrix==0){
									Row[row].Column[column]._matrix=len;
									if(params::containsKey("monitor")){
											mace::string str="Matrix Length: "+boost::lexical_cast<std::string>(len);
											downcall_route(MaceKey(ipv4,  params::get<std::string>("monitor")),  MonitorMsg(str));
									}
							}
							x++;
					}
					in.close();

					for(x=1; x<=Row[row].Column[column]._matrix; x++){
							for(y=1; y<=Row[row].Column[column]._matrix; y++){
									Position p;
									p.x=x;
									p.y=y;
									async_initialize(x,  y,  Row[row].Column[column]._positionValueMap[p],  Row[row].Column[column]._matrix);	
							}	
					}
					
			}else{
						mace::string str="Context Row["+boost::lexical_cast<std::string>(row)+"]Column["+boost::lexical_cast<std::string>(column)+"] has started!";
						if(params::containsKey("monitor")){
								downcall_route(MaceKey(ipv4,   params::get<std::string>("monitor")), MonitorMsg(str));
						}
						Row[row].Column[column]._matrix=matrix;

						if( (row ==1 && column==1) || (row==1 && column==matrix) || (row==matrix && column==1) ||
							 (row==matrix && column==matrix) ){
								Row[row].Column[column]._totalcount=3;
						}else if(row==1 || column==1 || row==matrix || column==matrix){
								Row[row].Column[column]._totalcount=5;
						}else{
								Row[row].Column[column]._totalcount=8;	
						}
						Row[row].Column[column]._myValue=value;

						if(params::containsKey("monitor")){
								mace::string str="Context Row["+boost::lexical_cast<std::string>(row)+"]Column["+boost::lexical_cast<std::string>(column)+"] has "+boost::lexical_cast<std::string>(Row[row].Column[column]._totalcount)+" neighbors!";	
								downcall_route( MaceKey(ipv4,  params::get<std::string>("monitor")),  MonitorMsg(str));	
						}

						distributeValue(row,  column,  matrix,  value);
			}
  }

	async [Row<row>::Column<column>] storeValue(int row,  int column,  int src_row,  int src_column,  int src_value){
			Position p;
			p.x=src_row;
			p.y=src_column;

			PositionValueMap::iterator iter=Row[row].Column[column]._positionValueMap.find(p);
			if(iter==Row[row].Column[column]._positionValueMap.end()){
					Row[row].Column[column]._positionValueMap[p]=src_value;
					Row[row].Column[column]._curcount++;
			}
			if(row==0 && column==0){
				/*
					if(Row[row].Column[column]._count==Row[row].Column[column]._matrix * Row[row].Column[column]._matrix){
							show_results(Row[row].Column[column]._positionValueMap,  Row[row].Column[column]._matrix);
							Row[row].Column[column]._count=0;
					}
				*/
			}else{
					if(Row[row].Column[column]._curcount == Row[row].Column[column]._totalcount){
							if(params::containsKey("monitor")){
									mace::string str=	"Row["+boost::lexical_cast<std::string>(row)+"]Column["+boost::lexical_cast<std::string>(column)+"] start round "+boost::lexical_cast<std::string>(Row[row].Column[column]._round);
									downcall_route( MaceKey(ipv4,  params::get<std::string>("monitor")),  MonitorMsg(str) );
							}

							Row[row].Column[column]._myValue=compute(row,  column,  Row[row].Column[column]._myValue,  Row[row].Column[column]._matrix,  Row[row].Column[column]._positionValueMap);
							
							Row[row].Column[column]._round++;

							distributeValue(row,  column,  Row[row].Column[column]._matrix,  Row[row].Column[column]._myValue);
							Row[row].Column[column]._curcount=0;
							Row[row].Column[column]._positionValueMap.clear();
					}
			}
	}

}

routines {

    int compute(int row,  int column,  int myValue,  int matrix,  PositionValueMap positionValueMap){
				int myState;
    	 	int total=0;
        for(int i=-1; i<=1; i++){
        		for(int j=-1; j<=1; j++){
								if(i==0 && j==0) continue;
								int x=row+i;
								int y=column+j;
								if(x<=0 || y<=0) continue;
								if(x>=matrix || y>=matrix) continue;
								Position vp;
								vp.x=x;
								vp.y=y;
								int value=positionValueMap[vp];
								total+=value;
						}
				}
				myState=myValue;
        if(myState==1){
        		if(total<2 || total>3) myState=0;
        }else{
            if(total==3) myState=1;
        }
        
				return myState;
		}

		void distributeValue(int row,  int column,  int matrix,  int value){
    		int i, j;
				Position p;
				p.x=row;
				p.y=column;
				if(params::containsKey("monitor")){
						downcall_route(MaceKey(ipv4,  params::get<std::string>("monitor")),  ValueMsg(p,  value));	
				}
				for(i=-1; i<=1; i++){
						for(j=-1; j<=1; j++){
								if(i==0 && j==0) continue;
								int x=row+i;
								int y=column+j;

								if(x<=0 || y<=0) continue;
								if(x>matrix || y>matrix) continue;
								async_storeValue(x,  y,  row,  column,  value);

						}	
				}
		}

		void show_results(PositionValueMap positionValueMap,  int matrix){
				std::cout<<"---------------------------------------------"<<std::endl;
				for(int i=1; i<=matrix; i++){
						for(int j=1; j<=matrix; j++){
								Position p;
								p.x=i;
								p.y=j;
								PositionValueMap::iterator iter=positionValueMap.find(p);
								if(iter==positionValueMap.end()){
										std::cout<<"fail to find value "<<i<<","<<j<<std::endl;
										return;
								}
								int value=iter->second;
								std::cout<<value<<" ";
						}
						std::cout<<std::endl;
				}
				std::cout<<"---------------------------------------------"<<std::endl;
		}
}


