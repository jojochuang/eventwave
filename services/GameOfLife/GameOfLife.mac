/* 
 * MPI.mac : part of the Mace toolkit for building distributed systems
 * 
 * Copyright (c) 2011, Wei-Chiu Chuang, Charles Killian, James W. Anderson
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the names of the contributors, nor their associated universities 
 *      or organizations may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * ----END-OF-LEGAL-STUFF---- 
*/

#include "mlist.h"
#include "marray.h"
#include "mdeque.h"

#include <sys/time.h>
#include <time.h>

using mace::NodeCollection;

service GameOfLife;
//provides GenericGameOfLife;
trace = med;

constants{
		uint64_t RESEND_TIMEOUT = 0.5*1000*1000;
		uint64_t TIMEOUT = 1*1000;
		int TOTAL_CONTEXT_NUM = 4;

		int TOTAL_ROUND=10000;
}

services {
    Transport tcp = TcpTransport();
}

states {
		
		WaitingResults;		//Master is waiting for compute results from workers

		Ready;			//Workers: have finished computation
		Computing;		//Workers: are computing
    	
}

constructor_parameters {
		// Master: the number of workers
}

auto_types {
		Position __attribute((comparable(equals=default; lessthan=default))) {
				int x;
				int y;
		}
}

typedefs {
    typedef mace::map<Position, int> PositionValueMap;
		typedef mace::vector< mace::vector<int> > Matrix;		
}

state_variables {
		timer _clock;
		double _start_time;
		time_t _start_time_sec;

		int _monitor_round;

		Matrix _monitor_matrix_values;
		int _elements_totalnum;
		int _elements_curnum;

		PositionValueMap _ready_map;
		
		context Row<uint32_t row>{
				context Column<uint32_t column>{
						int _totalcount;
						int _curcount;

						int _matrix;

						mace::vector<Position> _myPos;
						mace::vector<int> _myValues;

						Matrix _matrix_values;

						Position _min_p;
						Position _max_p;
						
						int _round;

						double _last_round_time;
						time_t _last_round_time_sec;
						time_t _start_time_sec;

						mace::vector<Position> _neig_contexts;
						mace::vector< mace::vector<Position> > _distributed_pos;
						mace::vector< mace::vector<int> > _distributed_values;
				}
		}

}


local_address {
  			return downcall_localAddress();
}

messages {
		MonitorMsg { mace::string msg; }
		ValueMsg { mace::vector<Position> myPos; mace::vector<int> myValues; }
		ValueMsg2 { Position p; int value; }

		ReadyMsg { int x;  int y; }
}

transitions {
  	downcall (state == init) maceInit() {
				if( params::containsKey("monitor") && MaceKey(ipv4,  params::get<std::string>("monitor"))==localAddress() ){
						std::cout<<"[monitor] monitor start!"<<std::endl;
						if(params::containsKey("elements_num")){
								_elements_totalnum=params::get<int>("elements_num");	
						}
						_monitor_round = 0;
						_elements_curnum = 0;

						timeval cur_time;
						gettimeofday(&cur_time,  NULL);
						_start_time = cur_time.tv_usec;
						_start_time_sec = time(NULL);

						//_clock.reschedule(TIMEOUT);
				}else{	
      			if( ContextMapping::getNodeByContext("") == localAddress() ){
								PositionValueMap posValueMap;
								initialize(0,  0,  posValueMap,  0 );	
						}
						resender_timer.reschedule(RESEND_TIMEOUT);
				}
  	}

  	downcall (state != init) maceExit() {
					      			
  	}

		scheduler _clock(){
				//std::cout<<"[monitor]Current Clock: "<<_clock_num<<std::endl;
				//_clock_num++;
				_clock.reschedule(TIMEOUT);
		}

		upcall deliver(const MaceKey& from,  const MaceKey& dest,  const MonitorMsg& msg){
				std::cout<<"[monitor]"<<msg.msg<<std::endl;				
		}

		upcall deliver(const MaceKey& from,  const MaceKey& dest,  const ReadyMsg& msg){
				Position p;
				p.x=msg.x;
				p.y=msg.y;

				_ready_map[p] = 1;

				if( (int)_ready_map.size() == TOTAL_CONTEXT_NUM){
						std::cout<<"[monitor]This round is: "<<_monitor_round<<std::endl;
						_monitor_round++;
						show_results(_monitor_matrix_values,  _elements_totalnum, _start_time,  _start_time_sec);

						_ready_map.clear();
				}
		}

		upcall deliver(const MaceKey& from,  const MaceKey& dest,  const ValueMsg& msg){
				mace::vector<Position> myPos = msg.myPos;
				mace::vector<int> myValue = msg.myValues;
				for(int i=0; i<(int)myPos.size(); i++){
						Position p = myPos[i];
						if(_monitor_matrix_values[p.x][p.y] < 0){
								_monitor_matrix_values[p.x][p.y] = myValue[i];
								_elements_curnum++;
						}
				}
				if( _elements_curnum == _elements_totalnum * _elements_totalnum){
						std::cout<<"[monitor]This round is: "<<_monitor_round<<std::endl;
						_monitor_round++;
						show_results(_monitor_matrix_values,  _elements_totalnum, _start_time,  _start_time_sec);
						for(int i=0; i < (int)_monitor_matrix_values.size(); i++){
								for(int j=0; j<(int)_monitor_matrix_values[i].size(); j++){
										_monitor_matrix_values[i][j] = -1;	
								}	
						}
						_elements_curnum=0;
						
				}
				
		}

		upcall deliver(const MaceKey& from,  const MaceKey& dest,  const ValueMsg2& msg){
				Position p=msg.p;
				if(p.x==0 && p.y==0){
							if(_elements_totalnum<=0){
									_elements_totalnum=msg.value;
									std::cout<<"[monitor]Input Matrix: "<<_elements_totalnum<<std::endl;

									_monitor_matrix_values.resize(_elements_totalnum+1);
									for(int i=0; i<(int)_monitor_matrix_values.size(); i++){
											_monitor_matrix_values[i].resize(_elements_totalnum+1);	
									}

									for(int i=0; i<(int)_monitor_matrix_values.size(); i++){
											for(int j=0; j<(int)_monitor_matrix_values[i].size(); j++){
														_monitor_matrix_values[i][j] = -1;
											}	
									}
							}
				}
		}


  async [Row<row>::Column<column>] initialize( int row,  int column, PositionValueMap posValueMap ,  int matrix) {
			if(params::containsKey("monitor")){
					mace::string str="Row["+boost::lexical_cast<std::string>(row)+"]Column["+boost::lexical_cast<std::string>(column)+"] start to initialize!";
					downcall_route(MaceKey(ipv4,  params::get<std::string>("monitor")),  MonitorMsg(str));	
			}

			__Column__Context &columnContext = Row[row].Column[column];

			columnContext._matrix=0;
			columnContext._totalcount=0;
			columnContext._curcount = 0;
			columnContext._round=1;
			if(row==0 && column==0){
					std::ifstream in("initstate.txt");
					int x=1;
					int y=1;
					int len=0;

					PositionValueMap myPosValueMap;
			 
					char buf[3000];
					while( !in.eof() ){
							y=1; 
							in.getline(buf, 3000);
							len=std::strlen(buf);
							for(int i=0; i<len; i++,  y++){
									Position p;
									p.x=x;
									p.y=y;
									if(buf[i]=='0'){
											myPosValueMap[p]=0;
									}else if(buf[i]=='1'){
											myPosValueMap[p]=1;
									}
							}
							if(columnContext._matrix==0){
									columnContext._matrix=len;
									if(params::containsKey("monitor")){
											Position mp;
											mp.x=0;
											mp.y=0;
											downcall_route(MaceKey(ipv4,  params::get<std::string>("monitor")),  ValueMsg2(mp,  len));
									}
							}
							x++;
					}
					in.close();

					PositionValueMap posValueMaps[TOTAL_CONTEXT_NUM];
					int context_matrix = getSquare(TOTAL_CONTEXT_NUM);
					len = columnContext._matrix;
					int sub_matrix = getSquare((len*len)/TOTAL_CONTEXT_NUM);
					
					if(params::containsKey("monitor")){
								mace::string str="context_matrix="+boost::lexical_cast<std::string>(context_matrix)+" sub_matrix="+boost::lexical_cast<std::string>(sub_matrix);	
								downcall_route( MaceKey(ipv4,  params::get<std::string>("monitor")),  MonitorMsg(str));	
					}
					Position curP;
					curP.x=1;
					curP.y=1;

					for(int i=0; i<TOTAL_CONTEXT_NUM; i++){
							int X, Y;

							if( curP.x+sub_matrix-1 <= len){
									X = curP.x+sub_matrix-1;	
							}else{
									X = len;	
							}

							if(curP.y+sub_matrix-1 <= len){
									Y = curP.y+sub_matrix-1;	
							}else{
									Y = len;	
							}

							for(int m=curP.x; m<=X; m++){
									for(int n=curP.y; n<=Y; n++){
												Position p;
												p.x = m;
												p.y = n;
												(posValueMaps[i])[p] = myPosValueMap[p];
												if(params::containsKey("monitor")){
														mace::string str="Add ("+boost::lexical_cast<std::string>(m)+", "+boost::lexical_cast<std::string>(n)+") to context "+boost::lexical_cast<std::string>(i);	
														//downcall_route( MaceKey(ipv4,  params::get<std::string>("monitor")),  MonitorMsg(str));	
												}
									}	
							}

							if(Y == len){
									curP.x+=sub_matrix;
									curP.y=1;
							}else{
									curP.y+=sub_matrix;	
							}
					}

					for(int i=0; i<TOTAL_CONTEXT_NUM; i++){
							int worker_row = i/context_matrix;
							int worker_column = i%context_matrix;

							worker_row++;
							worker_column++;

							async_initialize(worker_row,  worker_column,  posValueMaps[i],  columnContext._matrix);
					}

					
			}else{
						columnContext._matrix = matrix;
						columnContext._matrix_values.resize(matrix+1);
						for(int i=0; i< (int)columnContext._matrix_values.size(); i++){
								columnContext._matrix_values[i].resize(matrix+1);	
						}

						for(int i=0; i<(int)columnContext._matrix_values.size(); i++){
								for(int j=0; j<(int)columnContext._matrix_values[i].size(); j++){
										columnContext._matrix_values[i][j] = -1;
								}	
						}

						Position min_p,  max_p;
						min_p.x=10000;
						min_p.y=10000;
						max_p.x=0;
						max_p.y=0;

						int pos_n=0;
						int size = posValueMap.size();
						columnContext._myPos.resize(size);
						columnContext._myValues.resize(size);
						
						for(PositionValueMap::iterator iter=posValueMap.begin(); iter!=posValueMap.end(); iter++,  pos_n++){
								Position p = iter->first;
								columnContext._myPos[pos_n]=p;
								columnContext._myValues[pos_n]=iter->second;

								if(p.x <= min_p.x && p.y <= min_p.y){
										min_p=p;
								}

								if(max_p.x <= p.x && max_p.y <= p.y){
										max_p = p;	
								}
						}
						columnContext._min_p = min_p;
						columnContext._max_p = max_p;
						
						int totalcount = 0;
						if(min_p.x >1) totalcount+=max_p.y-min_p.y+1;
						if(min_p.y >1) totalcount+=max_p.x-min_p.x+1;

						if(max_p.x < matrix) totalcount += max_p.y-min_p.y+1;
						if(max_p.y < matrix) totalcount += max_p.x-min_p.x+1;

						if(min_p.x >1 && min_p.y >1) totalcount++;
						if(min_p.x >1 && max_p.y < matrix) totalcount++;
						if(max_p.x < matrix && min_p.y >1 ) totalcount++;
						if(max_p.x < matrix && max_p.y < matrix) totalcount++;
						columnContext._totalcount = totalcount;


						if(params::containsKey("monitor")){
								mace::string str1="Context Row["+boost::lexical_cast<std::string>(row)+"]Column["+boost::lexical_cast<std::string>(column)+"] has "+boost::lexical_cast<std::string>(Row[row].Column[column]._totalcount)+" neighbors!";
								mace::string str2="min:("+boost::lexical_cast<std::string>(min_p.x)+", "+boost::lexical_cast<std::string>(min_p.y)+") max:("+boost::lexical_cast<std::string>(max_p.x)+", "+boost::lexical_cast<std::string>(max_p.y)+")";
								downcall_route( MaceKey(ipv4,  params::get<std::string>("monitor")),  MonitorMsg(str1));
								downcall_route( MaceKey(ipv4,  params::get<std::string>("monitor")),  MonitorMsg(str2));
						}
						
						mace::map<Position,  PositionValueMap> distributed_values;
						PositionValueMap myPosValueMap = posValueMap;
						for(PositionValueMap::iterator iter=myPosValueMap.begin(); iter!=myPosValueMap.end(); iter++){
								Position p = iter->first;

								for(int i=-1; i<=1; i++){
										for(int j=-1; j<=1; j++){
												if(i==0 && j==0) continue;
												int x=p.x+i;
												int y=p.y+j;

												if(x<1 || y<1 || x>matrix || y>matrix) continue;
									
												int x_scope=0;
												int y_scope=0;

												if(x<=max_p.x && x>= min_p.x){
														x_scope=0;	
												}else if( x<min_p.x){
														x_scope=-1;	
												}else{
														x_scope=1;	
												} 

												if(y<=max_p.y && y>=min_p.y){
														y_scope=0;	
												}else if( y<min_p.y){
														y_scope=-1;	
												}else{
														y_scope=1;	
												}

												int context_row=row+x_scope;
												int context_column=column+y_scope;

												if(context_row==row && context_column==column){
													
												}else{
														
														Position context_p,  matrix_p;
														context_p.x = context_row;
														context_p.y = context_column;
														matrix_p.x = p.x;
														matrix_p.y = p.y;
														mace::map<Position,  PositionValueMap>::iterator diter = distributed_values.find(context_p);
														if(diter == distributed_values.end()){
																PositionValueMap tPosValueMap;
																tPosValueMap[matrix_p]=iter->second;
																distributed_values[context_p]=tPosValueMap;
														}else{
																(diter->second)[matrix_p]=iter->second;	
														}
												}
										}	
								}

						}


						size = distributed_values.size();
						columnContext._neig_contexts.resize(size);
						columnContext._distributed_pos.resize(size);
						columnContext._distributed_values.resize(size);
						mace::map<Position,  PositionValueMap>::iterator diter;

						int context_n=0;
						for(diter=distributed_values.begin(); diter!=distributed_values.end(); diter++,  context_n++){
									PositionValueMap tPosValueMap = diter->second;
									columnContext._neig_contexts[context_n] = diter->first;
									size = tPosValueMap.size();
									columnContext._distributed_pos[context_n].resize(size);
									columnContext._distributed_values[context_n].resize(size);

									int pos_n = 0;
									for(PositionValueMap::iterator iter=tPosValueMap.begin(); iter!=tPosValueMap.end(); iter++,  pos_n++){
											columnContext._distributed_pos[context_n][pos_n]=iter->first;
											columnContext._distributed_values[context_n][pos_n]=iter->second;
									}
						}

						for(int i=0; i<(int)Row[row].Column[column]._myPos.size(); i++){
								Position p = columnContext._myPos[i];
								columnContext._matrix_values[p.x][p.y]=columnContext._myValues[i];	
						}

						timeval cur_time;
						gettimeofday(&cur_time,  NULL);
						columnContext._last_round_time = cur_time.tv_usec;
						columnContext._start_time_sec = columnContext._last_round_time_sec = time(NULL);
						distributeValue(columnContext._myPos, columnContext._myValues,  
										columnContext._neig_contexts,  columnContext._distributed_pos, 
										columnContext._distributed_values,  columnContext._matrix_values);
			}
  }

	async [Row<row>::Column<column>] storeValues(int row,  int column,  mace::vector<int> x_pos, mace::vector<int> y_pos,   
					mace::vector<int> myValues){
			__Column__Context &columnContext = Row[row].Column[column];
			for(int i=0; i< (int)x_pos.size(); i++){
					int x=x_pos[i];
					int y=y_pos[i];
					
					if(columnContext._matrix_values[x][y]<0){
							columnContext._matrix_values[x][y]=myValues[i];
							columnContext._curcount++;
						/*
							timeval cur_time;
							gettimeofday(&cur_time,  NULL);
							
							if(params::containsKey("monitor")){
									mace::string str=	"Row["+boost::lexical_cast<std::string>(row)+"]Column["+boost::lexical_cast<std::string>(column)+"]  receive ("
											+boost::lexical_cast<std::string>(p.x)+", "+boost::lexical_cast<std::string>(p.y)+") at time:"
											+boost::lexical_cast<std::string>(cur_time.tv_usec-Row[row].Column[column]._last_round_time)+" round:"
											+boost::lexical_cast<std::string>(Row[row].Column[column]._round);
									downcall_route( MaceKey(ipv4,  params::get<std::string>("monitor")),  MonitorMsg(str) );
							}
						*/	
					}
			}
			if(row==0 && column==0){

			}else{
					if( columnContext._curcount == columnContext._totalcount){
						/*
							if(params::containsKey("monitor")){
									mace::string str=	"Row["+boost::lexical_cast<std::string>(row)+"]Column["+boost::lexical_cast<std::string>(column)+"] start round "+boost::lexical_cast<std::string>(Row[row].Column[column]._round);
									downcall_route( MaceKey(ipv4,  params::get<std::string>("monitor")),  MonitorMsg(str) );
							}
						*/
							for(int i=0; i<(int)columnContext._myPos.size(); i++){
									Position p=columnContext._myPos[i];
									columnContext._matrix_values[p.x][p.y]=columnContext._myValues[i];	
							}

							
							timeval before,  after;
							time_t before_sec, after_sec;
							gettimeofday(&before,  NULL);
							before_sec = time(NULL);
							/*
							Row[row].Column[column]._myValues = compute(row,  column,  Row[row].Column[column]._myPos,  Row[row].Column[column]._myValues,  
											Row[row].Column[column]._matrix_values,  Row[row].Column[column]._matrix);
							*/
							//maceout << "Before Computation!" <<Log::endl;
							mace::vector<int> new_myValues;
							int size = columnContext._myPos.size();
							new_myValues.resize(size);
							for(int m=0; m < size; m++){
									int myState = columnContext._myValues[m];
									Position p = columnContext._myPos[m];
    	 						int total=0;
        					for(int i=-1; i<=1; i++){
        							for(int j=-1; j<=1; j++){
													if(i==0 && j==0) continue;
													int x=p.x+i;
													int y=p.y+j;
													if(x<1 || y<1 || x> columnContext._matrix || y>columnContext._matrix) continue;
													int value = columnContext._matrix_values[x][y];
													if(value <0){
															if(params::containsKey("monitor")){
																	mace::string str=	"Row["+boost::lexical_cast<std::string>(row)+"]Column["+boost::lexical_cast<std::string>(column)+"] fail to receive round:"
																			+boost::lexical_cast<std::string>(Row[row].Column[column]._round)+" value:("
																			+boost::lexical_cast<std::string>(x)+", "+boost::lexical_cast<std::string>(y)+")";
																	downcall_route( MaceKey(ipv4,  params::get<std::string>("monitor")),  MonitorMsg(str) );
															}
													}else{
															total+=value;
													}
											}
									}
        					if(myState==1){
        							if(total<2 || total>3) myState=0;
        					}else{
            					if(total==3) myState=1;
        					}
       						new_myValues[m]=myState; 
							}
							columnContext._myValues = new_myValues;
							//maceout << "After Computation!" << Log::endl;
							

							after_sec = time(NULL);
							gettimeofday(&after,  NULL);

							double computation_time = after.tv_usec - before.tv_usec;
							time_t computation_time_sec = after_sec - before_sec;
							
							gettimeofday(&before,  NULL);
							before_sec = time(NULL);
							/*
							distributeValue( columnContext._myPos, columnContext._myValues,  columnContext._neig_contexts, 
											columnContext._distributed_pos,  columnContext._distributed_values, 
											columnContext._matrix_values);
							*/

							for(int i=0; i<(int)columnContext._neig_contexts.size();  i++){
									mace::vector<int> x_pos;
									mace::vector<int> y_pos;

									int size = columnContext._distributed_pos[i].size();
									x_pos.resize(size);
									y_pos.resize(size);
									for(int j=0; j<size;  j++){
											Position p = columnContext._distributed_pos[i][j];
											columnContext._distributed_values[i][j]=columnContext._matrix_values[p.x][p.y];
											x_pos[j] = p.x;
											y_pos[j] = p.y;
									}

									async_storeValues( columnContext._neig_contexts[i].x,  columnContext._neig_contexts[i].y, x_pos, y_pos,  columnContext._distributed_values[i] );
							}
							
							after_sec = time(NULL);
							gettimeofday(&after,  NULL);

							double distributed_time = after.tv_usec - before.tv_usec;
							time_t distributed_time_sec = after_sec - before_sec;

							if(params::containsKey("monitor")){
									mace::string str=	"Row["+boost::lexical_cast<std::string>(row)+"]Column["+boost::lexical_cast<std::string>(column)+"] round:"
											+boost::lexical_cast<std::string>(columnContext._round)
											+" computation time:"
											+boost::lexical_cast<std::string>(computation_time)+" "+boost::lexical_cast<std::string>(computation_time_sec)
											+" distributed time:"
											+boost::lexical_cast<std::string>(distributed_time)+" "+boost::lexical_cast<std::string>(distributed_time_sec)
											+" round time:"
											+boost::lexical_cast<std::string>(after.tv_usec-columnContext._last_round_time)+" "
											+boost::lexical_cast<std::string>(after_sec-columnContext._last_round_time_sec)+" "
											+boost::lexical_cast<std::string>(after_sec - columnContext._start_time_sec);

									downcall_route( MaceKey(ipv4,  params::get<std::string>("monitor")),  MonitorMsg(str) );
									downcall_route( MaceKey(ipv4,  params::get<std::string>("monitor")),  ReadyMsg(row,  column) );

							}
							columnContext._last_round_time = after.tv_usec;
							columnContext._last_round_time_sec = after_sec;
							
							columnContext._curcount = 0;
							columnContext._round++;

							
							for(int i=0; i< (int)columnContext._matrix_values.size(); i++){
									for(int j=0; j< (int)columnContext._matrix_values[i].size(); j++){
											columnContext._matrix_values[i][j]=-1;
									}	
							}
					}
			}
	}

}

routines {

		int getSquare(int total){
				if(total <= 0) return -1;
				int i=1;

				while(1){
						if( i*i > total) break;
						i++;
				}

				return (i-1);
		}

    mace::vector<int> compute(int row,  int column,  mace::vector<Position>& myPos,  mace::vector<int>& myValues,  
						Matrix& matrix_values,  int matrix){
				mace::vector<int> new_myValues;
				int size = myPos.size();
				new_myValues.resize(size);
				for(int m=0; m < size; m++){
						int myState = myValues[m];
						Position p = myPos[m];
    	 			int total=0;
        		for(int i=-1; i<=1; i++){
        				for(int j=-1; j<=1; j++){
										if(i==0 && j==0) continue;
										int x=p.x+i;
										int y=p.y+j;
										if(x<1 || y<1 || x>matrix || y>matrix) continue;
										int value = matrix_values[x][y];
										if(value <0){
												if(params::containsKey("monitor")){
														mace::string str=	"Row["+boost::lexical_cast<std::string>(row)+"]Column["+boost::lexical_cast<std::string>(column)+"] fail to receive round:"
																	+boost::lexical_cast<std::string>(Row[row].Column[column]._round)+" value:("
																	+boost::lexical_cast<std::string>(x)+", "+boost::lexical_cast<std::string>(y)+")";
														downcall_route( MaceKey(ipv4,  params::get<std::string>("monitor")),  MonitorMsg(str) );
												}
										}else{
												total+=value;
										}
								}
						}
        		if(myState==1){
        				if(total<2 || total>3) myState=0;
        		}else{
            		if(total==3) myState=1;
        		}
       			new_myValues[m]=myState; 
				}
				return new_myValues;
		}

	  void distributeValue( mace::vector<Position>& myPos, mace::vector<int>& myValues,  mace::vector<Position>& neig_contexts, 
											mace::vector< mace::vector<Position> >& distributed_pos,  
											mace::vector< mace::vector<int> >& distributed_values, 
											Matrix& matrix_values){
/*							
				if(params::containsKey("monitor")){
						downcall_route(MaceKey(ipv4,  params::get<std::string>("monitor")),  ValueMsg(myPos,  myValues));	
				}
	*/		
				for(int i=0; i<(int)neig_contexts.size();  i++){
						mace::vector<int> x_pos;
						mace::vector<int> y_pos;

						int size = distributed_pos[i].size();
						x_pos.resize(size);
						y_pos.resize(size);
						for(int j=0; j<size;  j++){
								Position p = distributed_pos[i][j];
								distributed_values[i][j]=matrix_values[p.x][p.y];
								x_pos[j] = p.x;
								y_pos[j] = p.y;
						}

						async_storeValues( neig_contexts[i].x,  neig_contexts[i].y, x_pos, y_pos,  distributed_values[i] );
				}				
				
		}

		void show_results(Matrix& _monitor_matrix_values,  int matrix, double start_time,  time_t start_time_sec){
				timeval cur_time;
				gettimeofday(&cur_time,  NULL);
				std::cout<<"[monitor]Current Clock: "<< cur_time.tv_usec-start_time <<" "<< time(NULL)-start_time_sec <<std::endl;
/*
				std::cout<<"[monitor]---------------------------------------------"<<std::endl;
				for(int i=1; i<=matrix; i++){
						std::cout<<"[monitor]";
						for(int j=1; j<=matrix; j++){
								Position p;
								p.x=i;
								p.y=j;
								PositionValueMap::iterator iter=positionValueMap.find(p);
								if(iter==positionValueMap.end()){
										std::cout<<"fail to find value "<<i<<","<<j<<std::endl;
										return;
								}
								int value=iter->second;
								std::cout<<value<<" ";
						}
						std::cout<<std::endl;
				}
				std::cout<<"[monitor]---------------------------------------------"<<std::endl;
*/
		}
}


