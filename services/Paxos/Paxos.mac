#include "mdeque.h"
#include "m_map.h"

service Paxos;
provides PaxosConsensus;

trace = med;

services {
	Transport tcp = TcpTransport();
}

state_variables {
	context Global {
		// common state variables 
		int role;
		mace::deque<MaceKey> acceptors;
	
		// Proposer state variables 																			
		uint64_t req_id_seq;
		mace::map<uint64_t, MaceKey> live_proposal;
		mace::map<uint64_t, uint64_t> clientID_map;
		MaceKey header;
		bool is_header;
		bool electing;
		mace::map<uint64_t, MaceKey> elect_map;
		
		// Acceptor state variables 
		mace::map<uint64_t, MaceKey> proposers_map;
	}
		
	
	context Proposal<uint64_t x> {
		uint64_t req_id;
		Key key;
		std::string value;
		int proposal_state;
		int count;
		mace::map<MaceKey, std::string> response_acceptors;

		int acceptors_num;
		MaceKey client; 
	}

	context Acceptor<uint64_t x> {
		mace::map<uint64_t, std::string> accept_value;
		uint64_t round;
		uint64_t key;
		uint64_t promised_req_id;
		bool value_selected;
		long accept_time;
	}

	context Client<uint64_t x> {
		uint64_t id;
		MaceKey proposer;
		Key key;
		std::string value;
		bool proposing;

		mace::map<Key, std::string> proposals;
	}
}

constants {
	long ACCEPT_EXPIRE_TIME = 10;

	int CLIENT = 0;
	int ACCEPTOR = 1;

	int PROPOSE_REFUSED = 2;
	int PROPOSE_ACCEPTED = 3;
	int PROPOSE_NEW_HEADER = 4;
	int PROPOSE_NOT_READY = 5;

	int PREPARING = 6;
	int ACCEPTING = 7;
}

messages {
		Propose {
			Key key;
			std::string value;
			uint64_t clientID;
		}

		ProposeReply {
			Key key;
			std::string value;
			MaceKey proposer;
			int reply_flag;
			uint64_t clientID;
		}

		Elect {
			uint64_t req_id_seq;	
		}

	  Prepare {
			uint64_t req_id;
			Key key;
			std::string value;
		}

		Accept {
			uint64_t req_id;
			Key key;
			std::string value;
		}
		
		Promise {
			uint64_t req_id;
			uint64_t key;
			std::string value;
		}
		
		Accepted {
			uint64_t req_id;
			uint64_t key;
			std::string value;
		}
						
}

auto_types {
	Key __attribute( (comparable(equals=default; lessthan=default)) ){
		uint64_t key;
		uint64_t round;
	}	
}

transitions {
	  downcall (state == init) maceInit() {
			async_initialize();
		}

		downcall [Global] set_acceptors(mace::deque<MaceKey>& acceptors_argu){
			acceptors = acceptors_argu;	
		}

		async [Global] initialize(){
			if(role == ACCEPTOR){
				req_id_seq = rand()%100;
				is_header = false;
				electing = false;
				header = MaceKey::null;
			}else if(role == CLIENT){
				async_init_client(acceptors[0]);
			}

		}

		async [Client] init_client(const MaceKey& proposer_header){
			proposer = proposer_header;	
		}

		/*************************Client******************************/
		downcall [Global] client_propose(const uint64_t& arg_id, const uint64_t& pro_key, const uint64_t& pro_round, const std::string& pro_value){
			if(role == CLIENT){
				Key key;
				key.key = pro_key;
				key.round = pro_round;
				async_client_propose2(arg_id, key, pro_value);	
			}	
		}

		upcall [__null] deliver(const MaceKey& from, const MaceKey& dest, const ProposeReply& msg){
				async_client_propose_reply(msg.clientID, msg.key, msg.value, msg.proposer, msg.reply_flag);
		}

		async [Client<arg_id>] client_propose2(const uint64_t& arg_id, const Key& pro_key, const std::string& pro_value){
			proposals[pro_key] = pro_value;
			if(!proposing){
				value = pro_value;
				key = pro_key;
				proposing = true;
				downcall_route(proposer, Propose(key, value, arg_id));
			}			
		}

		async [Client<clientID>] client_propose_reply(const uint64_t& clientID, const Key& arg_key, const std::string& arg_value, 
				const MaceKey& arg_proposer, const int& arg_reply_flag){
			if(proposing){
				if(arg_reply_flag == PROPOSE_ACCEPTED){
					if(key.key == arg_key.key && key.round == arg_key.round){
						proposing = false;
						proposals.erase(arg_key);
						mace::map<Key, std::string>::iterator iter = proposals.begin();
						if(	iter != proposals.end()){
							key = iter->first;
							value = iter->second;
							proposing = true;
							downcall_route(proposer, Propose(key, value, clientID));
						}
						upcall_propose_accepted(clientID, key.key, key.round, value);
					}
				}else if(arg_reply_flag == PROPOSE_REFUSED){
					if(key.key == arg_key.key && key.round == arg_key.round){
						proposing  = false;
						proposals.erase(arg_key);
						key = 0;
						mace::map<Key, std::string>::iterator iter = proposals.begin();
						if( iter != proposals.end()){
							key = iter->first;	
							value = iter->second;
							proposing = true;
							downcall_route(proposer, Propose(key, value, clientID));
						}
						upcall_propose_refused(clientID, key.key, key.round, value);
					}

				}else if(arg_reply_flag == PROPOSE_NEW_HEADER){
					if(key.key == arg_key.key && key.round == arg_key.round){
						proposer = arg_proposer;
						downcall_route(proposer, Propose(key, value, clientID));
					}
				}else if(arg_reply_flag == PROPOSE_NOT_READY){
					sleep(1);
					downcall_route(proposer, Propose(key, value, clientID));
				}	
			}
		}

																		
		/***************** Proposer ******************/
		upcall [Global] deliver(const MaceKey& from, const MaceKey& dest, const Propose& msg){
			if(role == ACCEPTOR){
					if(is_header){
						clientID_map[req_id_seq] = msg.clientID;
						live_proposal[req_id_seq++] = from;
						async_pro_propose(req_id_seq, msg.key, msg.value, (int)acceptors.size() );	
					}else if(header != MaceKey::null){
						downcall_route(from, ProposeReply(msg.key, msg.value, header, PROPOSE_NEW_HEADER));	
					}else if(header == MaceKey::null){
						downcall_route(from, ProposeReply(msg.key, msg.value, header, PROPOSE_NOT_READY));
						if(!electing){
							electing = true;
							elect_map.clear();
							elect_map[req_id_seq] = downcall_localAddress(); 
							int i;
							for(i=0; i<(int)acceptors.size(); i++){
								if(downcall_localAddress() == acceptors[i]){
									continue;
								}	

								downcall_route(acceptors[i], Elect(req_id_seq));
							}
						}
					}
			}	
		}

		async [Global] pro_propose_reply(const uint64_t& req_id, const Key& key, const std::string& value){
			mace::map<uint64_t, MaceKey>::iterator iter = live_proposal.find(req_id);
			if(iter != live_proposal.end()){
				downcall_route(iter->second, ProposeReply(key, value, header, PROPOSE_ACCEPTED, clientID_map[req_id]));
				live_proposal.erase(iter);
			}
		}

		upcall [Global] deliver(const MaceKey& from, const MaceKey& dest, const Elect& msg){
			if(!electing){
				elect_map.clear();
				elect_map[msg.req_id_seq] = from;
				elect_map[req_id_seq] = downcall_localAddress();
				electing = true;
				int i;
				for(i=0; i<(int)acceptors.size(); i++){
					if(downcall_localAddress() == acceptors[i]){
						continue;
					}	
					downcall_route(acceptors[i], Elect(req_id_seq));
				}

			}else{
				elect_map[msg.req_id_seq] = from;
				if(elect_map.size() >= acceptors.size()){
					mace::map<uint64_t, MaceKey>::iterator iter, max_iter;
					max_iter = iter = elect_map.begin();
					
					for(; iter!=elect_map.end(); iter++){
						if(max_iter->first < iter->first){
							max_iter = iter;	
						}	
					}

					header = max_iter->second;
					if(header == downcall_localAddress()){
						is_header = true;	
					}else{
						is_header = false;	
					}
					electing = false;
				}
			}	
		}

		upcall [Global] deliver(const MaceKey& from,  const MaceKey& dest,  const Prepare& msg){
			if(role == ACCEPTOR){
				proposers_map[msg.req_id] = from;
				async_acp_prepare(msg.req_id, msg.key, msg.value);	
					
			}	
		}

		upcall [Global] deliver(const MaceKey& from,  const MaceKey& dest,  const Promise& msg){
			if(role == ACCEPTOR){
				if(live_proposal.find(msg.req_id) != live_proposal.end()){
					async_pro_promise(msg.req_id, msg.key, msg.value, from);	
				}	
			}	
		}
		
		upcall [Global] deliver(const MaceKey& from,  const MaceKey& dest,  const Accept& msg){
			if(role == ACCEPTOR){
				async_acp_accept(msg.req_id, msg.key, msg.value);	
			}	
		}
	
		upcall [Global] deliver(const MaceKey& from,  const MaceKey& dest,  const Accepted& msg){
			if(role == ACCEPTOR){
				if(live_proposal.find(msg.req_id) != live_proposal.end()){
					async_pro_accepted(msg.req_id, msg.key, msg.value, from);	
				}	
			}	
		}	
		
		async [Proposal<req_seq>] pro_propose(const uint64_t& req_seq, const Key& req_key, const std::string& req_value, 
				const int& num){
			req_id = req_seq;
			key = req_key;
			value = req_value;
			proposal_state = PREPARING;
			count = 0;
			acceptors_num = num;

			async_send_prepare(req_id, key, value);
		}

		async [Global] send_prepare(const uint64_t& req_id, const Key& key, const std::string& value){
			int i;
			for(i=0; i<(int)acceptors.size(); i++){
				downcall_route(acceptors[i], Prepare(req_id, key, value));	
			}
		}
																																																										
																																																												
		async [Proposal<arg_req_id>] pro_promise(const uint64_t& arg_req_id, const Key& req_key, const std::string& req_value, 
				const MaceKey& acceptor){
			if(proposal_state == PREPARING){
				if(response_acceptors.find(acceptor) == response_acceptors.end()){
					response_acceptors[acceptor] = req_value;
					value = req_value;
					count ++;
					if(count>=acceptors_num/2){
						proposal_state = ACCEPTING;
						response_acceptors.clear();
						count = 0; 
						async_send_accept(arg_req_id, req_key, req_value);
					}
				}
			}
		}

		async [Global] send_accept(const uint64_t& req_id, const Key& key, const std::string& value){
			int i;
			for(i=0; i<(int)acceptors.size(); i++){
				downcall_route(acceptors[i], Accept(req_id, key, value));	
			}
		}
					
		// accept already sent
		async [Proposal<arg_req_id>] pro_accepted(const uint64_t& arg_req_id, const Key& req_key, const std::string& req_value, 
				const MaceKey& acceptor){
			if(proposal_state == ACCEPTING){
				if(response_acceptors.find(acceptor) == response_acceptors.end()){
					count++;
					response_acceptors[acceptor] = req_value;
					if(count>=acceptors_num/2){
						async_pro_propose_reply(arg_req_id, req_key, req_value);	
					}
				}	
			}	
		}

		
																																																																	
		/***************** Acceptor ******************/
		async [Acceptor<arg_key>] acp_prepare(const uint64_t& arg_req_id, const Key& arg_key, const std::string& arg_value){
				if(arg_key.round <= round){
					return;	
				}

				if (arg_req_id > promised_req_id) {
					promised_req_id = arg_req_id;
					async_send_promise(arg_req_id, arg_key, arg_value);
				}

		}

		async [Global] send_promise(const uint64_t& req_id, const Key& key, const std::string& value){
			downcall_route(proposers_map[req_id], Promise(req_id, key, value));	
		}

		async [Acceptor<arg_key>] acp_accept(const uint64_t& arg_req_id, const Key& arg_key, const std::string& arg_value){
			if(arg_req_id == promised_req_id){
				accept_value[arg_key.round] = arg_value;
				round = arg_key.round;
				async_send_accepted(arg_req_id, arg_key, arg_value);
			}	
		}

		async [Global] send_accepted(const uint64_t& req_id, const Key& key, const std::string& value){
			downcall_route(proposers_map[req_id], Accepted(req_id, key, value));	
		}
																																						
}

routines {
	 
		
}
