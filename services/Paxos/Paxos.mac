#include "mdeque.h"
#include "m_map.h"
#include "MaceTypes.h"
#include "RandomUtil.h"

service Paxos;
provides PaxosConsensus;

trace = med;

services {
	Transport tcp = TcpTransport();
}

state_variables {
	context Global {
		// common state variables 
		int role;
		mace::deque<MaceKey> acceptors;
	
		// Proposer state variables 																			
		uint64_t req_id_seq;
		mace::map<uint64_t, MaceKey> live_proposal;
		mace::map<uint64_t, uint64_t> clientID_map;
		MaceKey header;
		bool is_header;
		bool electing;
		mace::map<uint64_t, MaceKey> elect_map;
		
		// Acceptor state variables 
		mace::map<uint64_t, MaceKey> proposers_map;
		mace::map<uint64_t, bool> live_acceptors;
	}
		
	
	context Proposal<uint64_t x> {
		uint64_t req_id;
		Key key;
		std::string value;
		int proposal_state;
		int accept_count;
		int reply_count;
		mace::map<MaceKey, std::string> responses;

		uint64_t max_req_id;
		std::string max_value;
		uint64_t max_round;

		int acceptors_num;
		MaceKey client; 

		timer expire_timer;
		
	}

	context Acceptor<uint64_t x> {
		mace::map<uint64_t, std::string> accept_value;
		uint64_t round;
		uint64_t key;
		std::string value;

		uint64_t promised_req_id;
		
	}

	context Client<uint64_t x> {
		uint64_t id;
		MaceKey proposer;
		Key key;
		std::string value;
		bool proposing;

		mace::map<Key, std::string> proposals;
	}
}

constants {
	int CLIENT = 0;
	int ACCEPTOR = 1;

	int PROPOSE_REFUSED = 2;
	int PROPOSE_ACCEPTED = 3;
	int PROPOSE_NEW_HEADER = 4;
	int PROPOSE_NOT_READY = 5;

	int PREPARING = 6;
	int ACCEPTING = 7;
	int CLOSED = 8;

	int EXPIRE_TIME = 10;

	
}

messages {
		Propose {
			Key key;
			std::string value;
			uint64_t clientID;
		}

		ProposeReply {
			Key key;
			std::string value;
			MaceKey proposer;
			int reply_flag;
			uint64_t clientID;
		}

		Elect {
			uint64_t req_id_seq;	
		}

	  Prepare {
			uint64_t my_req_id;
			uint64_t req_id;
			Key key;
			std::string value;
		}

		Accept {
			uint64_t my_req_id;
			uint64_t req_id;
			Key key;
			std::string value;
		}
		
		Promise {
			uint64_t my_req_id;
			uint64_t req_id;
			Key key;
			std::string value;
			int rflag;
		}
		
		Accepted {
			uint64_t my_req_id;
			uint64_t req_id;
			Key key;
			std::string value;
			int rflag;
		}
						
}

auto_types {
	Key __attribute((comparable(equals=default; lessthan=default))) {
		uint64_t key;
		uint64_t round;
	}	
}

transitions {
	  downcall (state == init) maceInit() {
			int role = params::get<int>("ROLE");
			mace::deque<MaceKey> acceptors;
			NodeSet nodes = params::get<NodeSet>("ACCEPTORS");
			NodeSet::iterator iter = nodes.begin();
			while(iter != nodes.end()){
				acceptors.push_back(*iter);
				iter++;
			}
			async_initialize(role, acceptors);
		}

		downcall [Global] set_acceptors(const mace::deque<MaceKey>& acceptors_argu){
			acceptors = acceptors_argu;	
		}

		async [Global] initialize(const int& arg_role, const mace::deque<MaceKey>& arg_acceptors){
			ADD_SELECTORS("bsang");
			role = arg_role;
			acceptors = arg_acceptors;
			if(role == ACCEPTOR){

				srand(mace::getmtime());
				req_id_seq = rand()%10;
				
				is_header = false;
				electing = false;
				header = MaceKey::null;
				maceout<<"bsang: my init req_id_seq is "<<req_id_seq<<Log::endl;
			}else if(role == CLIENT){
				
			}

		}

		
		/*************************Client******************************/
		downcall [Global] client_propose(const uint64_t& arg_id, const uint64_t& pro_key, const uint64_t& pro_round, const std::string& pro_value){
			ADD_SELECTORS("bsang");
			if(role == CLIENT){
				maceout<<"bsang: to propose a proposal for ("<<pro_key<<", "<<pro_round<<")"<<Log::endl;
				Key key;
				key.key = pro_key;
				key.round = pro_round;
				async_client_propose2(arg_id, key, pro_value, acceptors[0]);	
			}	
		}

		upcall [Global] deliver(const MaceKey& from, const MaceKey& dest, const ProposeReply& msg){
			if(role == CLIENT){
				async_client_propose_reply(msg.clientID, msg.key, msg.value, msg.proposer, msg.reply_flag);
			}
		}

		async [Client<clientID>] client_propose2(const uint64_t& clientID, const Key& pro_key, const std::string& pro_value, 
				const MaceKey& header){
			ADD_SELECTORS("bsang");
			proposing = false;
			proposals[pro_key] = pro_value;
			if(!proposing) {
				maceout <<"bsang: Client "<<clientID<<" propose a proposal!"<<Log::endl;
				value = pro_value;
				key = pro_key;
				proposing = true;
				proposer = header;	
				downcall_route(proposer, Propose(key, value, clientID));
			}
		}

		async [Client<clientID>] client_propose_reply(const uint64_t& clientID, const Key& arg_key, const std::string& arg_value, 
				const MaceKey& arg_proposer, const int& arg_reply_flag){
			ADD_SELECTORS("bsang");
			if(proposing){
				if(arg_reply_flag == PROPOSE_ACCEPTED){
					if(key.key == arg_key.key){
						proposing = false;
						proposals.erase(arg_key);
						mace::map<Key, std::string>::iterator iter = proposals.begin();
						if(	iter != proposals.end()){
							key = iter->first;
							value = iter->second;
							proposing = true;
							downcall_route(proposer, Propose(key, value, clientID));
						}
						maceout<<"bsang: Client "<<clientID<<"'s proposal has been accepted!"<<Log::endl;
						upcall_propose_accepted(clientID, arg_key.key, arg_key.round, arg_value);
					}
				}else if(arg_reply_flag == PROPOSE_REFUSED){
					if(key.key == arg_key.key){
						maceout<<"bsang: Client "<<clientID<<"'s proposal has been refused!"<<Log::endl;
						proposing  = false;
						proposals.erase(arg_key);
						mace::map<Key, std::string>::iterator iter = proposals.begin();
						if( iter != proposals.end()){
							key = iter->first;	
							value = iter->second;
							proposing = true;
							downcall_route(proposer, Propose(key, value, clientID));
						}
						upcall_propose_refused(clientID, arg_key.key, arg_key.round, arg_value);
					}

				}else if(arg_reply_flag == PROPOSE_NEW_HEADER){
					if(key.key == arg_key.key){
						maceout<<"bsang: Client "<<clientID<<" receive a new header address"<<Log::endl;
						async_client_propose2(clientID, key, arg_value, arg_proposer);
					}
				}else if(arg_reply_flag == PROPOSE_NOT_READY){
					if(key.key == arg_key.key){
						maceout<<"bsang: Client "<<clientID<<" receive not ready reply"<<Log::endl;
						sleep(3);
						async_client_propose2(clientID, key, arg_value, proposer);
					}
				}	
			}
		}

																		
		/***************** Proposer ******************/
		upcall [Global] deliver(const MaceKey& from, const MaceKey& dest, const Propose& msg){
			if(role == ACCEPTOR){
					ADD_SELECTORS("bsang");
					if(is_header){
						maceout<<"bsang: receive a proposal from "<<msg.clientID<<" and ("<<req_id_seq<<", "<<msg.key.key<<", "<<msg.key.round<<")"<<Log::endl;
						clientID_map[req_id_seq] = msg.clientID;
						live_proposal[req_id_seq] = from;
						async_pro_propose(req_id_seq, msg.key, msg.value, (int)acceptors.size() );
						req_id_seq ++;
					}else if(header != MaceKey::null){
						downcall_route(from, ProposeReply(msg.key, msg.value, header, PROPOSE_NEW_HEADER, msg.clientID));	
					}else if(header == MaceKey::null){
						downcall_route(from, ProposeReply(msg.key, msg.value, header, PROPOSE_NOT_READY, msg.clientID));
						if(!electing){
							maceout<<"bsang: start to elect a leader"<<Log::endl;
							electing = true;
							elect_map.clear();
							elect_map[req_id_seq] = downcall_localAddress(); 
							int i;
							for(i=0; i<(int)acceptors.size(); i++){
								if(downcall_localAddress() == acceptors[i]){
									continue;
								}	

								downcall_route(acceptors[i], Elect(req_id_seq));
							}
						}
					}
			}	
		}

		async [Global] pro_propose_reply(const uint64_t& req_id, const Key& key, const std::string& value, const int& rflag){
			mace::map<uint64_t, MaceKey>::iterator iter = live_proposal.find(req_id);
			ADD_SELECTORS("bsang");
			if(iter != live_proposal.end()){
				int flag = rflag;
				maceout<<"bsang: send propose reply to client "<<clientID_map[req_id]<<Log::endl;
				downcall_route(iter->second, ProposeReply(key, value, header, flag, clientID_map[req_id]));
				
				live_proposal.erase(iter);
				clientID_map.erase(req_id);
			}
		}

		upcall [Global] deliver(const MaceKey& from, const MaceKey& dest, const Elect& msg){
			ADD_SELECTORS("bsang");
			if(!electing){
				maceout<<"bsang: start to elect the header"<<Log::endl;
				elect_map.clear();
				elect_map[msg.req_id_seq] = from;
				elect_map[req_id_seq] = downcall_localAddress();
				electing = true;
				int i;
				for(i=0; i<(int)acceptors.size(); i++){
					if(downcall_localAddress() == acceptors[i]){
						continue;

					}	
					downcall_route(acceptors[i], Elect(req_id_seq));
				}

			}else{
				elect_map[msg.req_id_seq] = from;
				if(elect_map.size() >= acceptors.size()){
					mace::map<uint64_t, MaceKey>::iterator iter, max_iter;
					max_iter = iter = elect_map.begin();
					
					for(; iter!=elect_map.end(); iter++){
						if(max_iter->first < iter->first){
							max_iter = iter;	
						}	
					}
					maceout<<"bsang: the header has been elected!"<<Log::endl;
					header = max_iter->second;
					if(header == downcall_localAddress()){
						maceout<<"bsang: I am the header!"<<Log::endl;
						is_header = true;	
					}else{
						maceout<<"bsang: I am not the header!"<<Log::endl;
						is_header = false;	
					}
					electing = false;
				}
			}	
		}

		upcall [Global] deliver(const MaceKey& from,  const MaceKey& dest,  const Promise& msg){
			if(role == ACCEPTOR){
				if(live_proposal.find(msg.req_id) != live_proposal.end()){
					async_pro_promise(msg.my_req_id, msg.req_id, msg.key, msg.value, msg.rflag, from);	
				}	
			}	
		}
		
		upcall [Global] deliver(const MaceKey& from,  const MaceKey& dest,  const Accepted& msg){
			if(role == ACCEPTOR){
				if(live_proposal.find(msg.req_id) != live_proposal.end()){
					async_pro_accepted(msg.my_req_id, msg.req_id,  msg.key, msg.value, msg.rflag, from);	
				}	
			}	
		}	
		
		async [Proposal<req_seq>] pro_propose(const uint64_t& req_seq, const Key& req_key, const std::string& req_value, 
				const int& num){
			ADD_SELECTORS("bsang")
			maceout<<"bsang: Proposal("<<req_seq<<") receive a propose("<<req_seq<<", "<<req_key.key<<", "<<req_key.round<<")"<<Log::endl;

			req_id = req_seq;
			key = req_key;
			value = req_value;
			proposal_state = PREPARING;
			accept_count = 0;
			reply_count = 0;
			max_round = req_key.round;
			max_req_id = req_id;
			acceptors_num = num;

			expire_timer.reschedule(EXPIRE_TIME, req_id);
			maceout<<"Proposal("<<req_seq<<") send prepare("<<req_seq<<", "<<key.key<<", "<<key.round<<") to acceptors"<<Log::endl;
			async_send_prepare(req_id, req_id, key, value);
		}

		async [Global] send_prepare(const uint64_t& my_req_id, const uint64_t& req_id, const Key& key, const std::string& value){
			int i;
			for(i=0; i<(int)acceptors.size(); i++){
				downcall_route(acceptors[i], Prepare(my_req_id, req_id, key, value));	
			}
		}
																																																										
																																																												
		async [Proposal<arg_my_req_id>] pro_promise(const uint64_t& arg_my_req_id, const uint64_t& arg_req_id, const Key& arg_key, 
				const std::string& arg_value, const int& arg_rflag, const MaceKey& response){
			if(proposal_state == PREPARING && responses.find(response) == responses.end()){
				ADD_SELECTORS("bsang")
				maceout<<"bsang: Proposal("<<arg_my_req_id<<") receive a promise("<<arg_req_id<<", "<<arg_key.key<<", "<<arg_key.round<<", "<<arg_rflag<<")"<<Log::endl;
			
				responses[response] = arg_value;
				if(arg_rflag == PROPOSE_ACCEPTED){
					accept_count ++;
					reply_count ++;
					if(accept_count>=acceptors_num/2){
						proposal_state = ACCEPTING;
						responses.clear();
						accept_count = 0; 
						reply_count = 0;
						max_round = -1;
						max_req_id = -1;
						if(expire_timer.isScheduled()){
							expire_timer.cancel();	
						}
						expire_timer.reschedule(EXPIRE_TIME, arg_my_req_id);
						maceout<<"Proposal("<<arg_my_req_id<<") send accept("<<req_id<<", "<<key.key<<", "<<key.round<<") to acceptors"<<Log::endl;
						async_send_accept(arg_my_req_id, req_id, key, value);
					}else if(reply_count >= acceptors_num){
						key.round = max_round;
						value = max_value;
						req_id = max_req_id;

						responses.clear();
						reply_count = 0;
						accept_count = 0;
						max_round = -1;
						max_req_id = -1;

						if(expire_timer.isScheduled()){
							expire_timer.cancel();	
						}
						expire_timer.reschedule(EXPIRE_TIME, arg_my_req_id);
						maceout<<"Proposal("<<arg_my_req_id<<") send accept("<<req_id<<", "<<key.key<<", "<<key.round<<") to acceptors"<<Log::endl;
						async_send_accept(arg_my_req_id, req_id, key, value);	
					}
				}else if(arg_rflag == PROPOSE_REFUSED){
					reply_count ++;
					if(arg_key.round > max_round){
						max_round = arg_key.round;	
					}
					if(arg_req_id >= max_req_id){
						max_req_id = arg_req_id;
						max_value = arg_value;
					}

					if(reply_count >= acceptors_num){
						key.round = max_round;
						value = max_value;
						req_id = max_req_id;

						responses.clear();
						reply_count = 0;
						accept_count = 0;
						max_round = -1;
						max_req_id = -1;

						if(expire_timer.isScheduled()){
							expire_timer.cancel();	
						}
						expire_timer.reschedule(EXPIRE_TIME, arg_my_req_id);
						maceout<<"Proposal("<<arg_my_req_id<<") send accept("<<req_id<<", "<<key.key<<", "<<key.round<<") to acceptors"<<Log::endl;
						async_send_accept(arg_my_req_id, req_id, key, value);
					}
				}
			}
		}

		async [Global] send_accept(const uint64_t& my_req_id, const uint64_t& req_id, const Key& key, const std::string& value){
			int i;
			for(i=0; i<(int)acceptors.size(); i++){
				downcall_route(acceptors[i], Accept(my_req_id, req_id, key, value));	
			}
		}
					
		// accept already sent
		async [Proposal<arg_my_req_id>] pro_accepted(const uint64_t& arg_my_req_id, const uint64_t& arg_req_id, 
				const Key& arg_key, const std::string& arg_value,	const int& rflag, const MaceKey& response){
			if(proposal_state == ACCEPTING && responses.find(response) == responses.end()){
				ADD_SELECTORS("bsang")
				maceout<<"bsang: Proposal("<<arg_my_req_id<<") receive a accepted("<<arg_req_id<<", "<<arg_key.key<<", "<<arg_key.round<<", "<<rflag<<")"<<Log::endl;
			
				responses[response] = arg_value;
				if(rflag == PROPOSE_ACCEPTED){
					accept_count ++;
					reply_count ++;
					if(accept_count >= acceptors_num/2){
						if(expire_timer.isScheduled()){
							expire_timer.cancel();	
						}
						proposal_state = CLOSED;
						async_pro_propose_reply(arg_my_req_id, key, value, PROPOSE_ACCEPTED);	
					}else if(reply_count >= acceptors_num){
						if(expire_timer.isScheduled()){
							expire_timer.cancel();	
						}	
						key.round = max_round;
						value = max_value;
						req_id = max_req_id;
						proposal_state = CLOSED;
						async_pro_propose_reply(arg_my_req_id, key, value, PROPOSE_REFUSED);
					}
				}else if(rflag == PROPOSE_REFUSED){
					reply_count ++;
					if(reply_count >= acceptors_num){
						if(expire_timer.isScheduled()){
							expire_timer.cancel();	
						}	
						key.round = max_round;
						value = max_value;
						req_id = max_req_id;
						proposal_state = CLOSED;
						async_pro_propose_reply(arg_my_req_id, key, value, PROPOSE_REFUSED);
					}
				}	
			}	
		}

		scheduler [Proposal<arg_my_req_id>] expire_timer(uint64_t& arg_my_req_id) {
			if(proposal_state != CLOSED ){
				ADD_SELECTORS("bsang");
				maceout<<"In Proposal("<<arg_my_req_id<<") time expired. Send prepare again!"<<Log::endl;
				proposal_state = PREPARING;
				async_send_prepare(arg_my_req_id, req_id, key, value);
			}	
		}
																																																																	
		/***************** Acceptor ******************/
		upcall [Global] deliver(const MaceKey& from,  const MaceKey& dest,  const Prepare& msg){
			if(role == ACCEPTOR){
				ADD_SELECTORS("bsang");
				maceout<<"Receive a prepare msg from Proposal("<<msg.my_req_id<<")"<<Log::endl;
				proposers_map[msg.my_req_id] = from;
				if(live_acceptors.find(msg.key.key) == live_acceptors.end()){
					live_acceptors[msg.key.key] = true;
					async_acp_init(msg.key.key);
				}
				async_acp_prepare(msg.my_req_id, msg.req_id, msg.key.key, msg.key, msg.value);	
			}	
		}

		async [Acceptor<acp_key>] acp_init(const uint64_t& acp_key){
			ADD_SELECTORS("bsang");
			maceout<<"Initialize Acceptor("<<acp_key<<")!"<<Log::endl;
			round = 0;
			promised_req_id = 0;
			key = acp_key;
		}
		
		async [Acceptor<acp_key>] acp_prepare(const uint64_t& arg_my_req_id, const uint64_t& arg_req_id, const uint64_t& acp_key, const Key& arg_key, 
					const std::string& arg_value){
				ADD_SELECTORS("bsang")
				maceout<<"bsang: Acceptor("<<acp_key<<") receive a prepare("<<arg_req_id<<", "<<acp_key<<", "<<arg_key.round<<") from "<<arg_my_req_id<<Log::endl;
				maceout<<"Acceptor("<<acp_key<<") current round is "<<round<<Log::endl;
				
				if(arg_key.round <= round){
					Key reply_key;
					reply_key.key = key;
					reply_key.round = round;
					async_send_promise(arg_req_id, reply_key, accept_value[round], arg_req_id, PROPOSE_REFUSED);
				}else{
					if (arg_req_id >= promised_req_id) {
						promised_req_id = arg_req_id;
						value = arg_value;
						maceout<<"Acceptor("<<acp_key<<") reply to Proposal("<<arg_my_req_id<<"): ("<<arg_req_id<<", "<<arg_key.key<<", "<<arg_key.round<<")"<<Log::endl;
						async_send_promise(arg_my_req_id, arg_key, arg_value, arg_req_id, PROPOSE_ACCEPTED);
					}else{
						maceout<<"Acceptor("<<acp_key<<") reply to Proposal("<<arg_my_req_id<<"): ("<<promised_req_id<<", "<<arg_key.key<<", "<<arg_key.round<<")"<<Log::endl;
						async_send_promise(arg_my_req_id, arg_key, value, promised_req_id, PROPOSE_REFUSED);
					}
				}
		}

		async [Global] send_promise(const uint64_t& req_id, const Key& key, const std::string& value, const uint64_t& max_req_id, 
				const int& flag){
			downcall_route(proposers_map[req_id], Promise(req_id, max_req_id, key, value, flag));	
		}
		
		upcall [Global] deliver(const MaceKey& from,  const MaceKey& dest,  const Accept& msg){
			if(role == ACCEPTOR){
				async_acp_accept(msg.my_req_id, msg.req_id, msg.key.key, msg.key, msg.value);	
			}	
		}

		async [Acceptor<acp_key>] acp_accept(const uint64_t& arg_my_req_id, const uint64_t& arg_req_id, const uint64_t& acp_key, 
				const Key& arg_key,	const std::string& arg_value){
			ADD_SELECTORS("bsang")
			maceout<<"bsang: Acceptor("<<acp_key<<") receive an accept("<<arg_req_id<<", "<<acp_key<<", "<<arg_key.round<<") from "<<arg_my_req_id<<Log::endl;
			
			if(arg_req_id == promised_req_id && arg_key.round > round){
				accept_value[arg_key.round] = arg_value;
				round = arg_key.round;
				async_send_accepted(arg_my_req_id, arg_req_id, arg_key, arg_value, PROPOSE_ACCEPTED);
			}else{
				Key reply_key;
				reply_key.key = key;
				reply_key.round = round;
				async_send_accepted(arg_my_req_id, promised_req_id, reply_key, value, PROPOSE_REFUSED);
			}	
		}

		async [Global] send_accepted(const uint64_t& req_id, const uint64_t& max_req_id, const Key& key, const std::string& value, 
				const int& rflag){
			downcall_route(proposers_map[req_id], Accepted(req_id, max_req_id, key, value, rflag));	
		}
																																						
}

routines {
	 
		
}
