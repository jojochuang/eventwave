#include "MaceTime.h"
#include "mdeque.h"
#include "m_map.h"

using mace::string;
using Log::endl;

service Paxos;

provides Consensus;

trace=med;

services {
	Transport tcp = TcpTransport();
}

states {
	  
}

state_variables {
	/* common state variables */
	int role;
	mace::deque<MaceKey> acceptors;
	
	/* Proposer state variables */																			
	uint64_t req_seq;
	mace::map<uint64_t, MaceKey> live_proposal;
	MaceKey header;
	bool is_header;
	bool electing;

	mace::map<unit64_t, MaceKey> elect_map;
	
	context Proposal<uint64_t> {
		uint64_t req_id;
		uint64_t key;
		std::string value;
		int proposal_state;
		int count;
		mace::map<MaceKey, std::string> response_acceptors;
		MaceKey client; 
	}

	/* Acceptor state variables */
	mace::map<uint64_t, MaceKey> proposers_map;

	context Acceptor<uint64_t> {
		std::string accept_value;
		uint64_t key;
		uint64_t promised_req_id;
		bool value_selected;
		long accept_time;
	}

	/* Client state variables	*/
	context Client {
		MaceKey proposer;
		uint64_t key;
		std::string value;
		bool proposing;

		mace::map<uint64_t, std::string> proposals;
	}
}

constants {
	long ACCEPT_EXPIRE_TIME = 10;

	int CLIENT = 0;
	int ACCEPTOR = 1;

	int PROPOSE_REFUSED = 2;
	int PROPOSE_ACCEPTED = 3;
	int PROPOSE_NEW_HEADER = 4;
	int PROPOSE_NOT_READY = 5;
}

messages {
		Propose {
			uint64_t key;
			std::string value;
		}

		ProposeReply {
			uint64_t key;
			std::string value;
			MaceKey proposer;
			int reply_flag;
		}

		Elect {
			uint64_t req_id_seq;	
		}

	  Prepare {
			uint64_t req_id;
			uint64_t key;
			std::string value;
		}

		Accept {
			uint64_t req_id;
			uint64_t key;
			std::string value;
		}
		
		Promise {
			uint64_t req_id;
			uint64_t key;
			std::string value;
		}
		
		Accepted {
			uint64_t req_id;
			uint64_t key;
			std::string value;
		}
						
}

auto_types {
	Proposal_struct {
		uint64_t key;
		std::string value;
		MaceKey client;
	}	
}

transitions {
	  downcall (state == init) maceInit() {
			if(role == ACCEPTOR){
				req_seq = rand()%100;
				is_header = false;
				electing = false;
				header = MaceKey::null;
			}else if(role == CLIENT){
				proposer = acceptors[0];
			}
		}

		/*************************Client******************************/
		downcall [__null] client_propose(const uint64_t& pro_key, const string& pro_value){
			if(role == CLIENT){
				async_client_propose2(pro_key, pro_value);	
			}	
		}

		upcall [__null] deliver(const MaceKey& from, const MaceKey& dest, const ProposeReply& msg){
				async_client_propose_reply(msg);
		}

		async [Client] client_propose2(const uint64_t& pro_key, const string& pro_value){
			proposals[pro_key] = pro_value;
			if(!proposing){
				value = pro_value;
				key = pro_key;
				proposing = true;
				douncall_route(proposer, Propose(key, value));
			}			
		}

		async [Client] client_propose_reply(const ProposeReply& msg){
			if(proposing){
				if(msg.reply_flag == PROPOSE_ACCEPTED){
					if(key == msg.key){
						proposing = false;
						proposals.erase(msg.key);
						key = 0;
						mace::map<uint64_t, std::string>::iterator iter = proposals.begin();
						if(	iter != proposals.end()){
							key = iter->first;
							value = iter->second;
							proposing = true;
							downcall_route(proposer, Propose(key, value));
						}
						upcall_propose_accepted(key, value);
					}
				}else if(msg.reply_flag == PROPOSE_REFUSED){
					if(key == msg.key){
						proposing  = false;
						proposals.erase(msg.key);
						key = 0;
						mace::map<uint64_t, std::string>::iterator iter = proposals.begin();
						if( iter != proposals.end()){
							key = iter->first;	
							value = iter->second;
							proposing = true;
							downcall_route(proposer, Propose(key, value));
						}
						upcall_propose_refused(key, value);
					}

				}else if(msg.reply_flag == PROPOSE_NEW_HEADER){
					if(key == msg.key){
						proposer = msg.proposer;
						downcall_route(proposer, Propose(key, value));
					}
				}else if(msg.reply_flag == PROPOSE_NOT_READY){
					
				}	
			}
		}

																		
		/***************** Proposer ******************/
		upcall [__null] deliver(const MaceKey& from, const MaceKey& dest, Propose& msg){
			if(role == ACCEPTOR){
					if(is_header){
						live_proposal[req_seq++] = from;
						async_pro_propose(req_seq, msg.key, msg.value);	
					}else if(header != MaceKey::null){
						downcall_route(from, ProposeReply(msg.key, msg.value, header, PROPOSE_NEW_HEADER));	
					}else if(header == MaceKey::null){
						downcall_route(from, ProposeReply(msg.key, msg.value, header, PROPOSE_NOT_READY));
						if(!electing){
							electing = true;
							elect_map.clear();
							elect_map[req_id_seq] = downcall_localAddress(); 
							int i;
							for(i=0; i<(int)acceptors.size(); i++){
								if(downcall_localAddress() == acceptors[i]){
									continue;
								}	

								downcall_route(acceptors[i], Elect(req_id_seq));
							}
						}
					}
			}	
		}

		async [__null] pro_propose_reply(const uint64_t& req_id, const uint64_t& key, const std::string& value){
			mace::map<uint64_t, MaceKey>::iterator iter = live_proposal.find(req_id);
			if(iter != live_proposal.end()){
				downcall_route(iter->second, ProposeReply(key, value, header, PROPOSE_ACCEPTED));
				live_proposal.erase(iter);
			}
		}

		upcall [__null] deliver(const MaceKey& from, const MaceKey& dest, Elect& msg){
			if(!electing){
				elect_map.clear();
				elect_map[msg.req_id_seq] = from;
				elect_map[req_id_seq] = downcall_localAddress();
				electing = true;
				int i;
				for(i=0; i<(int)acceptors.size(); i++){
					if(downcall_localAddress() == acceptors[i]){
						continue;
					}	
					downcall_route(acceptors[i], Elect(req_id_seq));
				}

			}else{
				elect_map[msg.req_id_seq] = from;
				if(elect_map.size() >= acceptors.size()){
					mace::map<uint64_t, MaceKey>::iterator iter, max_iter;
					max_iter = iter = elect_map.begin();
					
					for(; iter!=elect_map.end(); iter++){
						if(max_iter->first < iter->first){
							max_iter = iter;	
						}	
					}

					header = max_iter->second;
					if(header == downcall_localAddress()){
						is_header = true;	
					}else{
						is_header = false;	
					}
					electing = false;
				}
			}	
		}

		upcall [__null] deliver(const MaceKey& from,  const MaceKey& dest,  const Prepare& msg){
			if(role == ACCEPTOR){
				proposers_map[msg.req_id] = from;
				async_acp_prepare(msg.req_id, msg.key, msg.value);	
					
			}	
		}

		upcall [__null] deliver(const MaceKey& from,  const MaceKey& dest,  const Promise& msg){
			if(role == ACCEPTOR){
				if(live_proposal.find(msg.req_id) != live_proposal.end()){
					async_pro_promise(msg.req_id, msg.key, msg.value);	
				}	
			}	
		}
		
		upcall [__null] deliver(const MaceKey& from,  const MaceKey& dest,  const Accept& msg){
			if(role == ACCEPTOR){
				async_acp_accept(msg.req_id, msg.key, msg.value);	
			}	
		}
	
		upcall [__null] deliver(const MaceKey& from,  const MaceKey& dest,  const Accepted& msg){
			if(role == ACCEPTOR){
				if(live_proposal.find(msg.req_id) != live_proposal.end()){
					async_pro_accepted(msg.req_id, msg.key, msg.value);	
				}	
			}	
		}	
		
		async [Proposal<req_seq>] pro_propose(const uint64_t& req_seq, const uint64_t& req_key, const string& req_value){
			req_id = req_seq;
			key = req_key;
			value = req_value;
			proposal_state = PREPARING;
			accept_count = 0;

			sendPrepare(req_id, key, value);
		}
																																																										
																																																												
		async [Proposal<req_id>] pro_promise(const uint64_t& req_id, const uint64_t& req_key, const string& req_value, 
				uint64_t& acceptor_id){
			if(proposal_state == PREPARING){
				if(response_acceptors.find(acceptor_id) == response_acceptors.end()){
					response_acceptors[acceptor_id] = req_value;
					value = req_value;
					count ++;
					if(count>=getAcceptorNum()/2){
						proposal_state = ACCEPTING;
						response_acceptors.clear();
						count = 0; 
						sendAccept(req_id, req_key, req_value);
					}
				}
			}
		}
					
		// accept already sent
		async [Proposal<req_id>] pro_accepted(const uint64_t& req_id, const uint64_t& req_key, const string& req_value, 
				uint64_t& acceptor_id){
			if(proposal_state == ACCEPTING){
				if(response_acceptors.find(acceptor_id) == respose_acceptors.end()){
					count++;
					response_acceptors[acceptor_id] = req_value;
					if(count>=getAcceptorNum()/2){
						async_propose_reply(req_id, req_key, req_value);	
					}
				}	
			}	
		}
																																																																	
		/***************** Acceptor ******************/
		async [Acceptor<key>] acp_prepare(const uint64_t& req_id, const uint64_t& key, const std::string& value){
				if(value_selected){
					if( (getCurTime()-accept_time) < ACCEPT_EXPIRE_TIME){
						return;	
					}	
				}

				if (req_id > promised_req_id) {
					promised_req_id = req_id;
					sendPromise(req_id, key, value);
				}

		}

		async [Acceptor<key>] acp_accept(const uint64_t& req_id, const uint64_t& key, const std::string& value){
			if(req_id == promised_req_id){
				accept_value = value;
				value_selected = true;
				accept_time = getCurTime();
				sendAccepted(req_id, key, value);
			}	
		}
																																						
}

routines {
	  [__null] long getCurTime() {
		
		}
		
		[__null] void sendPrepare(const uint64_t& req_id, const uint64_t& key, const std::string& value) {
			mace::deque<MaceKey> acceptors = getAcceptors();
			int i;
			for(i=0; i<(int)acceptors.size(); i++){
				downcall_route(acceptors[i], Prepare(req_id, key, value));	
			}
		}
																											
		[__null] void sendAccept(const uint64_t& req_id, const uint64_t& key, const std::string& value) {
			mace::deque<MaceKey> acceptors = getAcceptors();
			int i;
			for(i=0; i<(int)acceptors.size(); i++){
				downcall_route(acceptors[i], Accept(req_id, key, value));	
			}
		}
																																				
		[__null] mace::deque<MaceKey> getAcceptors() {
		
		}

		[__null] sendAccepted(uint64_t& req_id, uint64_t& key, std::string& value){
			MaceKey addr = proposers_map[req_id];
			downcall_route(addr, Accepted(req_id, key, value));
		}

		[__null] sendPromise(uint64_t& req_id, uint64_t& key, std::string& value){
			MaceKey addr = proposers_map[req_id];
			downcall_route(addr, Promise(req_id, key, value));
		}
}
