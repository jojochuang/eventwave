#include "GlobalCommit.h"
#include "Ticket.h"

service CommitTransportWrapper;

provides Transport;

trace=med;

services
{
  Transport trans = TcpTransport();
}


messages 
{
  Data {
    MaceKey source;
    MaceKey dest;
    registration_uid_t regId;
    mace::string data;
  }
}

auto_types {
  Packet {
    MaceKey src;
    MaceKey dest;
    registration_uid_t regId;
    mace::string data;
  }
}

typedefs {
  typedef mace::deque<Packet> MessageQueue;
}

state_variables {
  MaceKey me;
  MessageQueue queued;
}

transitions 
{
  downcall maceInit() {
    mace::SpecificCommitWrapper<CommitTransportWrapperService>* executor = new mace::SpecificCommitWrapper<CommitTransportWrapperService>(this, &CommitTransportWrapperService::commitCallBack);
    mace::GlobalCommit::registerCommitExecutor(executor);
  }
  downcall route(const MaceKey& dest, const std::string& msg, registration_uid_t regId) {
    macedbg(1) << "comparing my ticket("<<Ticket::myTicket()<<") with current ticket("<<Ticket::current_ticket()<<")" << Log::endl;

    if( Ticket::checkTicket() ) {
      downcall_route(dest, Data(me, dest, regId, data));  // send immediately
    } else {
      queued.push_front(Packet(dest, me, regId, msg));    // queue else
    }
    return true;
  }
  upcall deliver(const MaceKey& src, const MaceKey& dest, const Data& msg) {
    upcall_deliver(msg.source, msg.dest, msg.data, msg.regId);
  }
  upcall error(const MaceKey& nodeId, TransportError::type error_code, const std::string& m, registration_uid_t registrationUid) {
    upcallAllVoid(error, nodeId, error_code, m);
  }
  upcall messageError(const MaceKey& dest, TransportError::type error_code, const Data& msg, registration_uid_t regId) {
    upcall_messageError(msg.dest, error_code, msg.data, msg.regId);
  }
  downcall getLocalAddress() {
    return downcall_getLocalAddress();
  }
}


routines {
  void commitCallBack(uint64_t myTicket) {
    macedbg(1) << "commitCallback called. Processing outstanding" << queued.size() << "messages." << Log::endl;
    MessageQueue::iterator i;
    for (i=queued.begin(); i!= queued.end(); i++) {
      Packet m = *i;
      downcall_route(m.dest, Data(m.src, m.dest, m.regId, m.data));
    }
  }

}

