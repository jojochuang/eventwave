// #include <boost/algorithm/string.hpp>
#include "SysUtil.h"
#include "GlobalCommit.h"
#include "Ticket.h"

using mace::string;
using mace::MonotoneTime;

service SignedMulticast;

provides Multicast;

trace=high;
incontext=on;
//locking=off;

services {
  Multicast m = GenericTreeMulticast();
}

//Note - for context data, would like to have message filtering.
messages {
  Data {
    string data;
    string signature;
    registration_uid_t rid;
  }
}

auto_types {
  // shyoo : deferred upcall support
  DeferredPacket {
    MaceKey src;
    MaceKey groupId;
    mace::string data;
    registration_uid_t regId;
  }
}


typedefs {
  // shyoo : deferred upcall support
  typedef mace::deque<DeferredPacket> MessageQueue;
}

state_variables {
  //context<MaceKey groupId> {
    //state for fns
  //}

  // shyoo : deferred upcall support
  MessageQueue queued;
}

constructor_parameters {
  uint64_t delay = 0;
}


transitions {
  downcall maceInit() {
    // read in group state

    // shyoo : deferred upcall support
    mace::SpecificCommitWrapper<SignedMulticastService>* executor = new mace::SpecificCommitWrapper<SignedMulticastService>(this, &SignedMulticastService::commitCallBack);
    mace::GlobalCommit::registerCommitExecutor(executor);
  }

  //context<groupId> {
    downcall multicast(const MaceKey& groupId, const string& s, registration_uid_t rid) [locking=read] {
      string sig = createSignature(s);
      return downcall_multicast(groupId, Data(s, sig, rid));
    }

    upcall forward(const MaceKey& src, const MaceKey& groupId, MaceKey& nexthop, const Data& msg) [locking=read] {
      static const bool DOWNGRADE_TO_NONE = params::get("DOWNGRADE_TO_NONE", false);
      if (DOWNGRADE_TO_NONE) {
          DOWNGRADE(NONE_MODE);
      } else {
          DOWNGRADE(READ_MODE);
      }
      bool result = verifySignature(msg.data, msg.signature);
      return result;
    }

    upcall deliver(const MaceKey& src, const MaceKey& groupId, const Data& msg) [locking=read] {
      // shyoo: this is deferrable.
      //upcall_deliver(src, groupId, msg.data, msg.rid);

      // shyoo : deferred upcall support
      deferred_upcall_deliver(src, groupId, msg.data, msg.rid);

    }
  //}
}

routines {
  //these somehow inherit context?
  string createSignature(const string& data) const {
    // for demonstration, we'll need something which takes time here.
    //sleep(3);
    SysUtil::sleepu(delay);
    return data;
  }

  bool verifySignature(const string& data, const string& signature) const {
    // for demonstration, we'll need something which takes time here.
    SysUtil::sleepu(delay);
    //sleep(3);
    return true;
  }

  // shyoo : deferred upcall support
  void commitCallBack(uint64_t myTicket) {
    macedbg(1) << "commitCallback called. Processing outstanding" << queued.size() << "messages." << Log::endl;
    MessageQueue::iterator i;
    for (i=queued.begin(); i!= queued.end(); i++) {
      DeferredPacket m = *i;
      upcall_deliver(m.src, m.groupId, m.data, m.regId);
    }
  }

  // shyoo : deferred upcall support
  void deferred_upcall_deliver(const MaceKey& src, const MaceKey& groupId, const mace::string& data, const registration_uid_t& rid) 
  {
    macedbg(1) << "comparing my ticket("<<Ticket::myTicket()<<") with current ticket("<<Ticket::current_ticket()<<")" << Log::endl;

    if( Ticket::myTicket() == Ticket::current_ticket() ) {
      upcall_deliver(src, groupId, data, rid);    // deliver immediately
    } else {
      queued.push_front(DeferredPacket(src, groupId, data, rid));    // queue else
    }
  }


}

